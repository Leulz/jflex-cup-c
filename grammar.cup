import java_cup.runtime.*;
import model.*;

action code {:
  private Semantic semanticAnalyser = new Semantic();
:};

parser code {:
  public parser(java.io.Reader input) {
  	super(new Lexer(input));
  }

  /* Change the method syntax_error so when it reports a syntax
     error it will foward the problematic symbol to report_error.*/
  public void syntax_error(java_cup.runtime.Symbol cur_token) {
  	report_error("Syntax error", cur_token);
  }

  public void unrecovered_syntax_error(java_cup.runtime.Symbol cur_token) {
	report_fatal_error("Syntax error, couldn't repair and continue parse", cur_token);
  }


  /* Change the method report_error so it will display the line and
     column of where the error occurred in the input as well as the
     reason for the error which is passed into the method in the
     String 'message'. It will differ between type of error. */
  public void report_error(String message, Object info) {
  	/* Create a StringBuilder called 'm' with the string 'Error' in it. */
  	StringBuilder m = new StringBuilder("Error");

  	/* Check if the information passed to the method is the same
  	   type as the type java_cup.runtime.Symbol. */
  	if (info instanceof java_cup.runtime.Symbol) {
  		/* Declare a java_cup.runtime.Symbol object 's' with the
  		   information in the object info that is being typecasted
  		   as a java_cup.runtime.Symbol object. */
  		java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

  		/* Check if the line number in the input is greater or
  		   equal to zero. */
  		if (s.left >= 0) {
  			/* Add to the end of the StringBuilder error message
  			   the line number of the error in the input. */
  			m.append(" in line " + (s.left + 1));
  			/* Check if the column number in the input is greater
  			   or equal to zero. */
  			if (s.right >= 0)
  				/* Add to the end of the StringBuilder error message
  				   the column number of the error in the input. */
  				m.append(", column " + (s.right + 1));
  		}
  	}
	
  	/* Add to the end of the StringBuilder error message created in
  	   this method the message that was passed into this method. */
  	m.append(" : " + message);
  	/* Print the contents of the StringBuilder 'm', which contains
  	   an error message, out on a line. */
  	System.err.println(m);
  }

  /* Change the method report_fatal_error so when it reports a fatal
     error it will display the line and column number of where the
     fatal error occurred in the input as well as the reason for the
     fatal error which is passed into the method in the object
     'message' and then exit.*/
  public void report_fatal_error(String message, Object info) {
  	report_error(message, info);
  	System.exit(1);
  }
:};

// Terminals (tokens returned by the scanner)
terminal	IDENTIFIER;
terminal	ENUMERATION_CONSTANT;
terminal	TYPEDEF_NAME;

terminal	AUTO;
terminal	BREAK;
terminal	CASE;
terminal	CHAR;
terminal	CONST;
terminal	CONTINUE;
terminal	DEFAULT;
terminal	DO;
terminal	DOUBLE;
terminal	ELSE;
terminal	ENUM;
terminal	EXTERN;

terminal	FLOAT;
terminal	FOR;
terminal	GOTO;
terminal	IF;
terminal	INLINE;
terminal	INT;
terminal	LONG;
terminal	REGISTER;
terminal	RESTRICT;
terminal	RETURN;
terminal	SHORT;

terminal	SIGNED;
terminal	SIZEOF;
terminal	STATIC;
terminal	STRUCT;
terminal	SWITCH;
terminal	TYPEDEF;
terminal	UNION;
terminal	UNSIGNED;
terminal	VOID;
terminal	VOLATILE;
terminal	WHILE;

terminal	ALIGNAS;
terminal	ALIGNOF;
terminal	ATOMIC;
terminal	BOOL;
terminal	COMPLEX;
terminal	GENERIC;
terminal	IMAGINARY;
terminal	NORETURN;
terminal	STATIC_ASSERT;
terminal	THREAD_LOCAL;

terminal	FUNC_NAME;
terminal	I_CONSTANT;
terminal	F_CONSTANT;
terminal	STRING_LITERAL;

terminal	ELLIPSIS;		// ...
terminal	RIGHT_ASSIGN;	// >>=
terminal	LEFT_ASSIGN;	// <<=
terminal	ADD_ASSIGN;		// +=
terminal	SUB_ASSIGN;		// -=
terminal	MUL_ASSIGN;		// *=
terminal	DIV_ASSIGN;		// /=
terminal	MOD_ASSIGN;		// %=
terminal	AND_ASSIGN;		// &=
terminal	XOR_ASSIGN;		// ^=
terminal	OR_ASSIGN;		// |=
terminal	RIGHT_OP;		// >>
terminal	LEFT_OP;		// <<
terminal	INC_OP;			// ++
terminal	DEC_OP;			// --
terminal	PTR_OP;			// ->
terminal	AND_OP;			// &&
terminal	OR_OP;			// ||
terminal	LE_OP;			// <=
terminal	GE_OP;			// >=
terminal	EQ_OP;			// ==
terminal	NE_OP;			// !=

terminal	SEMICOLON;	// ;
terminal	LCURLY;		// {
terminal	RCURLY;		// }
terminal	COMMA;		// ,
terminal	COLON;		// :
terminal	ASSIGN;		// =
terminal	LPAREN;		// (
terminal	RPAREN;		// )
terminal	LBRACKET;	// [
terminal	RBRACKET;	// ]
terminal	DOT;		// .
terminal	AND;		// &
terminal	NE;			// !
terminal	COMPLEMENT;	// ~
terminal	SUB;		// -
terminal	ADD;		// +
terminal	MUL;		// *
terminal	DIV;		// /
terminal	MOD;		// %
terminal	LE;			// <
terminal	GE;			// >
terminal	XOR;		// ^
terminal	OR;			// |
terminal	QUESTION;	// ?

// Nonterminals
non terminal translation_unit, external_declaration, function_definition, declaration_list, primary_expression;
non terminal constant, enumeration_constant, string, generic_selection, generic_assoc_list, generic_association;
non terminal postfix_expression, argument_expression_list, unary_expression, unary_operator, cast_expression;
non terminal multiplicative_expression, additive_expression, shift_expression, relational_expression;
non terminal equality_expression, and_expression, exclusive_or_expression, inclusive_or_expression;
non terminal logical_and_expression, logical_or_expression, conditional_expression, assignment_expression;
non terminal assignment_operator, expression, constant_expression, declaration, declaration_specifiers;
non terminal init_declarator_list, init_declarator, storage_class_specifier, type_specifier, struct_or_union_specifier;
non terminal struct_or_union, struct_declaration_list, struct_declaration, specifier_qualifier_list, struct_declarator_list;
non terminal struct_declarator, enum_specifier, enumerator_list, enumerator, atomic_type_specifier, type_qualifier;
non terminal function_specifier, alignment_specifier, declarator, direct_declarator, pointer, type_qualifier_list;
non terminal parameter_type_list, parameter_list, parameter_declaration, identifier_list, type_name, abstract_declarator;
non terminal direct_abstract_declarator, initializer, initializer_list, designation, designator_list, designator;
non terminal static_assert_declaration, statement, labeled_statement, compound_statement, block_item_list;
non terminal block_item, expression_statement, selection_statement, iteration_statement, jump_statement;

precedence nonassoc ELSE;
precedence nonassoc ATOMIC;

start with translation_unit;

translation_unit	::= external_declaration
					| translation_unit external_declaration;

external_declaration	::= function_definition
						| declaration;

function_definition	::= declaration_specifiers declarator declaration_list compound_statement
					| declaration_specifiers declarator compound_statement;

// eg: static int; , static  , _Static_assert(x, "oi");
declaration	::= declaration_specifiers SEMICOLON
			| declaration_specifiers:t init_declarator_list:v SEMICOLON {: semanticAnalyser.commitDeclaredVariables((Type) t); :}
			| static_assert_declaration;

// eg: typedef static , static , int static , int , const static , const , 
// inline const , inline , _Alignas() static , _Alignas()
declaration_specifiers	::= storage_class_specifier declaration_specifiers:t {: RESULT = t; :}
						| storage_class_specifier
						| type_specifier declaration_specifiers
						| type_specifier:t {: RESULT = t; :}
						| type_qualifier declaration_specifiers
						| type_qualifier
						| function_specifier declaration_specifiers
						| function_specifier
						| alignment_specifier declaration_specifiers
						| alignment_specifier;

// eg: *x, x
declarator	::= pointer direct_declarator
			| direct_declarator:v {: RESULT=v; :};

declaration_list	::= declaration
					| declaration_list declaration;

// eg: {} , { int i = 0; }
compound_statement	::= LCURLY RCURLY
					| LCURLY  block_item_list RCURLY;

// eg:
init_declarator_list	::= init_declarator:v {: RESULT=v; :}
						| init_declarator_list COMMA init_declarator;

// eg: _Static_assert(x, "oi");
static_assert_declaration	::= STATIC_ASSERT LPAREN constant_expression COMMA STRING_LITERAL RPAREN SEMICOLON;

// identifiers must be flagged as TYPEDEF_NAME
// eg: typedef , extern , static , _Thread_local , auto , register
storage_class_specifier ::= TYPEDEF
						| EXTERN
						| STATIC
						| THREAD_LOCAL
						| AUTO
						| REGISTER;

// eg: void , char , short , int , long , float , double , signed , unsigned ,
// bool , _Complex , _Imaginary , _Atomic(int) , enum{ML, MN} , Retangle
type_specifier	::= VOID
				| CHAR
				| SHORT
				| INT:i {: RESULT = new Type("int"); :}
				| LONG
				| FLOAT
				| DOUBLE
				| SIGNED
				| UNSIGNED
				| BOOL
				| COMPLEX
				| IMAGINARY
				| atomic_type_specifier
				| struct_or_union_specifier
				| enum_specifier
				| TYPEDEF_NAME;

// eg: const , restrict , volatile , _Atomic
type_qualifier	::= CONST
				| RESTRICT
				| VOLATILE
				| ATOMIC;

// eg: inline , _Noreturn
function_specifier	::= INLINE
					| NORETURN;

// eg: _Alignas(int) , _Alignas()
alignment_specifier	::= ALIGNAS LPAREN type_name RPAREN
					| ALIGNAS LPAREN constant_expression RPAREN;

// eg: *const, volatile* , *const, volatile , ** , * 
pointer	::= MUL type_qualifier_list pointer
		| MUL type_qualifier_list
		| MUL pointer
		| MUL;

// eg: x , (x) , x[] , x[*] , x[static int i = 0] , x[static i = 0] , x[int*] , 
// x[int static i = 0] , x[int i = 0] , x[int] , x[i = 0], x(int, int) , x(), x(a, b, c)
direct_declarator	::= IDENTIFIER:id {: System.out.println("Saw an identifier in a declaration.");
                                      Variable v = new Variable((String) id, new Type("null"));
                                      semanticAnalyser.addScopedVar(v);
                                      RESULT = v; :}
					| LPAREN declarator RPAREN
					| direct_declarator LBRACKET RBRACKET
					| direct_declarator LBRACKET MUL RBRACKET
					| direct_declarator LBRACKET STATIC type_qualifier_list assignment_expression RBRACKET
					| direct_declarator LBRACKET STATIC assignment_expression RBRACKET
					| direct_declarator LBRACKET type_qualifier_list MUL RBRACKET
					| direct_declarator LBRACKET type_qualifier_list STATIC assignment_expression RBRACKET
					| direct_declarator LBRACKET type_qualifier_list assignment_expression RBRACKET
					| direct_declarator LBRACKET type_qualifier_list RBRACKET
					| direct_declarator LBRACKET assignment_expression RBRACKET
					| direct_declarator LPAREN parameter_type_list RPAREN
					| direct_declarator LPAREN RPAREN
					| direct_declarator LPAREN identifier_list RPAREN;

// eg: int i = 0; , int i = 0; int j = i;
block_item_list	::= block_item
				| block_item_list block_item;

// eg: *x = , *x
init_declarator	::= declarator ASSIGN initializer
				| declarator:v {: RESULT=v; :};

// with constraints
// eg: x
constant_expression	::= conditional_expression;

// eg: _Atomic(int)
atomic_type_specifier	::= ATOMIC LPAREN type_name RPAREN;

struct_or_union_specifier	::= struct_or_union LCURLY struct_declaration_list RCURLY
							| struct_or_union IDENTIFIER LCURLY struct_declaration_list RCURLY
							| struct_or_union IDENTIFIER;

// eg: enum{ML, MN} , enum{ML, MN,} , enum data{ML, MN} , enum data{ML, MN,} , enum data
enum_specifier	::= ENUM LCURLY enumerator_list RCURLY
				| ENUM LCURLY enumerator_list COMMA RCURLY
				| ENUM IDENTIFIER LCURLY enumerator_list RCURLY
				| ENUM IDENTIFIER LCURLY enumerator_list COMMA RCURLY
				| ENUM IDENTIFIER;

type_name	::= specifier_qualifier_list abstract_declarator
			| specifier_qualifier_list;

// eg: const , volatile const
type_qualifier_list	::= type_qualifier
					| type_qualifier_list type_qualifier;

// Here we defined the 14º precedence on operators in C, the assignment operators, 
// which can be used to assign values (expressions) to variables. The unary operators
// are the only ones allowed to operate on the variables receiving values.
// eg: x , a + b , i++ , x++ = a + b , a += m , i *= 2
assignment_expression	::= conditional_expression
						| unary_expression assignment_operator assignment_expression;

// eg: int x, int y, ... , int x
parameter_type_list	::= parameter_list COMMA ELLIPSIS
					| parameter_list;

// eg: x , x, a, b
identifier_list	::= IDENTIFIER
				| identifier_list COMMA IDENTIFIER;

block_item	::= declaration
			| statement;

// eg: {[i][j] = 12} , {[i][j] = 12,} , {x} , {x,} , x , 12
initializer	::= LCURLY initializer_list RCURLY
			| LCURLY initializer_list COMMA RCURLY
			| assignment_expression;

// Here we defined the 13º precedence on operators in C, the ternary conditional "?:",
// which allows to create a mini if-then-else calculation. Note the restriction on the values to
// be evaluated as bool or not, and the else value.
// eg: x , a + b , i++ , x > 2 ? 12 : x + 12 , condition ? i += 2 : condition2 ? j += 2 : 0
conditional_expression	::= logical_or_expression
						| logical_or_expression QUESTION expression COLON conditional_expression;

// eg: struct , union
struct_or_union ::= STRUCT
				| UNION;

// eg: char; , char; char;
struct_declaration_list	::= struct_declaration
						| struct_declaration_list struct_declaration;

// eg: ML, ML, MN
enumerator_list	::= enumerator
				| enumerator_list COMMA enumerator;

// eg: char int , char , const char , const
specifier_qualifier_list	::= type_specifier specifier_qualifier_list
							| type_specifier
							| type_qualifier specifier_qualifier_list
							| type_qualifier;

// eg: *[] , * , []
abstract_declarator	::= pointer direct_abstract_declarator
					| pointer
					| direct_abstract_declarator;

// eg: x , ++x , --x , *(int) x , sizeof x , sizeof(int) , _Alignof(int)
unary_expression	::= postfix_expression
					| INC_OP unary_expression
					| DEC_OP unary_expression
					| unary_operator cast_expression
					| SIZEOF unary_expression
					| SIZEOF LPAREN type_name RPAREN
					| ALIGNOF LPAREN type_name RPAREN;

// eg: = , *= , /= , %= , += , -= , <<= , >>= , &= , ^= , |=
assignment_operator	::= ASSIGN
					| MUL_ASSIGN
					| DIV_ASSIGN
					| MOD_ASSIGN
					| ADD_ASSIGN
					| SUB_ASSIGN
					| LEFT_ASSIGN
					| RIGHT_ASSIGN
					| AND_ASSIGN
					| XOR_ASSIGN
					| OR_ASSIGN;

// eg: int x , int x, int y
parameter_list	::= parameter_declaration
				| parameter_list COMMA parameter_declaration;

statement	::= labeled_statement
			| compound_statement
			| expression_statement
			| selection_statement
			| iteration_statement
			| jump_statement;

// eg: [i][j] = 12 , x , 12 , x, [i][j] = 12 , x, y
initializer_list	::= designation initializer
					| initializer
					| initializer_list COMMA designation initializer
					| initializer_list COMMA initializer;

// Here we defined the 12º precedence on operators in C, the logical or "||".
// It's used to evaluate bool values on the conditions in C.
// eg: x , x || a
logical_or_expression	::= logical_and_expression
						| logical_or_expression OR_OP logical_and_expression;

// Its anything that can be evaluated to a value of any type available or defined.
// Here, we define the lowest precedence (15º) of the operators on C, the "," that
// tie expressions to be passed as functions parameters or declarations.
// eg: x , a = 2 , a + b , a + (-b) , x, a = 2
expression	::= assignment_expression
			| expression COMMA assignment_expression;

// for anonymous struct/union
// eg: char; , char int; , 
struct_declaration	::= specifier_qualifier_list SEMICOLON
					| specifier_qualifier_list struct_declarator_list SEMICOLON
					| static_assert_declaration;

// identifiers must be flagged as ENUMERATION_CONSTANT
// eg: ML = x, ML
enumerator	::= enumeration_constant ASSIGN constant_expression
			| enumeration_constant;

// eg: (*) , [] , [*] , [static const i = 0] , [static i = 0], [const static i = 0] ,
// [const] , [i = 0] , [][] , [][*] , [][static const i = 0], [][static i = 0], 
// [][const i = 0] , [][const static i = 0], [][const], [][i = 0] , (), (int x, int y) ,
// []() , [](int x, int y)
direct_abstract_declarator	::= LPAREN abstract_declarator RPAREN
							| LBRACKET RBRACKET
							| LBRACKET MUL RBRACKET
							| LBRACKET STATIC type_qualifier_list assignment_expression RBRACKET
							| LBRACKET STATIC assignment_expression RBRACKET
							| LBRACKET type_qualifier_list STATIC assignment_expression RBRACKET
							| LBRACKET type_qualifier_list assignment_expression RBRACKET
							| LBRACKET type_qualifier_list RBRACKET
							| LBRACKET assignment_expression RBRACKET
							| direct_abstract_declarator LBRACKET RBRACKET
							| direct_abstract_declarator LBRACKET MUL RBRACKET
							| direct_abstract_declarator LBRACKET STATIC type_qualifier_list assignment_expression RBRACKET
							| direct_abstract_declarator LBRACKET STATIC assignment_expression RBRACKET
							| direct_abstract_declarator LBRACKET type_qualifier_list assignment_expression RBRACKET
							| direct_abstract_declarator LBRACKET type_qualifier_list STATIC assignment_expression RBRACKET
							| direct_abstract_declarator LBRACKET type_qualifier_list RBRACKET
							| direct_abstract_declarator LBRACKET assignment_expression RBRACKET
							| LPAREN RPAREN
							| LPAREN parameter_type_list RPAREN
							| direct_abstract_declarator LPAREN RPAREN
							| direct_abstract_declarator LPAREN parameter_type_list RPAREN;

// eg: x , x(20) , f() , f(a = 2, b = 3) , x.a , x->a , x++ , x-- , (Retangle){a = 2} , {Retangle}{a = 2,}
postfix_expression	::= primary_expression
					| postfix_expression LBRACKET expression RBRACKET
					| postfix_expression LPAREN RPAREN
					| postfix_expression LPAREN argument_expression_list RPAREN
					| postfix_expression DOT IDENTIFIER
					| postfix_expression PTR_OP IDENTIFIER
					| postfix_expression INC_OP
					| postfix_expression DEC_OP
					| LPAREN type_name RPAREN LCURLY initializer_list RCURLY
					| LPAREN type_name RPAREN LCURLY initializer_list COMMA RCURLY;

// eg: & , * , + , - , ~ , !
unary_operator	::= AND
				| MUL
				| ADD
				| SUB
				| COMPLEMENT
				| NE;

// eg: x , (int) x
cast_expression	::= unary_expression
				| LPAREN type_name RPAREN cast_expression;

// eg: int x , int* , int
parameter_declaration	::= declaration_specifiers declarator
						| declaration_specifiers abstract_declarator
						| declaration_specifiers;

labeled_statement	::= IDENTIFIER COLON statement
					| CASE constant_expression COLON statement
					| DEFAULT COLON statement;

// eg: ; , x = 1;
expression_statement	::= SEMICOLON
						| expression SEMICOLON;

// eg: if(x > 2) a = x; else a = y; , if(x > 2) a = x; , switch(x) a = x;
selection_statement	::= IF LPAREN expression RPAREN statement ELSE statement
					| IF LPAREN expression RPAREN statement
					| SWITCH LPAREN expression RPAREN statement;

// eg: while(x > 2) i++; , do i++; while(x > 2); , for(;;) i++; ,
// for(;; i++) a = b + 2; , for(int i = 0; x > 2) i++; , for(int i = 0; x > 2; i++) x += a;
iteration_statement	::= WHILE LPAREN expression RPAREN statement
					| DO statement WHILE LPAREN expression RPAREN SEMICOLON
					| FOR LPAREN expression_statement expression_statement RPAREN statement
					| FOR LPAREN expression_statement expression_statement expression RPAREN statement
					| FOR LPAREN declaration expression_statement RPAREN statement
					| FOR LPAREN declaration expression_statement expression RPAREN statement;

// eg: goto start; , continue; , break; , return; , return x + 1;
jump_statement	::= GOTO IDENTIFIER SEMICOLON
				| CONTINUE SEMICOLON
				| BREAK SEMICOLON
				| RETURN SEMICOLON
				| RETURN expression SEMICOLON;

// Assignment of a designator chain like in matrix[i][j] = 2
// eg: [i][j] = , [x].a = , .left.left =
designation	::= designator_list ASSIGN;

// Here we defined the 11º precedence on operators in C, the logical and "&&".
// It's used to evaluate bool values on the conditions in C.
// eg: x , x && a
logical_and_expression	::= inclusive_or_expression
						| logical_and_expression AND_OP inclusive_or_expression;

// eg: :x , :x, :a
struct_declarator_list	::= struct_declarator
						| struct_declarator_list COMMA struct_declarator;

// Stands for the constants defined in enums BEFORE it has been defined as such.
// eg: ML , MAX_INT , MIN , STEP
enumeration_constant	::= IDENTIFIER;

// The foremost basic element of an expression, comprehends identifiers,
// numbers constants, strings, expression on parenthesis and generics selections.
// eg: x , a , b , 11 , 12.2 , 0xA2 , "oi" , "tchau" , "Hi, Leo!" , 
// (x >= 2) , (a == (i = j + i + 1)) , _Generic(x = 1, int: x = 2)
primary_expression	::= IDENTIFIER
					| constant
					| string
					| LPAREN expression RPAREN
					| generic_selection;

// eg: x = a + 2 , x = 2, a = 0
argument_expression_list	::= assignment_expression
							| argument_expression_list COMMA assignment_expression;

// A chain of designations like in matrix[i][j], or tree.left.left
// eg: [i] , [i][j] , .left.left
designator_list	::= designator
				| designator_list designator;

// eg: x , x | y
inclusive_or_expression	::= exclusive_or_expression
						| inclusive_or_expression OR exclusive_or_expression;

// eg: :x , *x:a , *x
struct_declarator	::= COLON constant_expression
					| declarator COLON constant_expression
					| declarator;

// It represents a specific number of value. Includes character_constant
// eg: 1001 , 20.5 , MAX
constant	::= I_CONSTANT
			| F_CONSTANT
			| ENUMERATION_CONSTANT;

// It represents a specifi text
// eg: "oi" , __func__
string	::= STRING_LITERAL
		| FUNC_NAME;

// eg: _Generic(x = 1, int: x = 2)
generic_selection	::= GENERIC LPAREN assignment_expression COMMA generic_assoc_list RPAREN;

// It specifies an adress related to the Identifier, like in
// ball[12] or ball.radius.
// eg: [i] , [12] , .radius
designator	::= LBRACKET constant_expression RBRACKET
			| DOT IDENTIFIER;

// eg: x , x ^ y
exclusive_or_expression	::= and_expression
						| exclusive_or_expression XOR and_expression;

// eg: int: x = 2 , int: x = 2, default: x = 0
generic_assoc_list	::= generic_association
					| generic_assoc_list COMMA generic_association;

// eg: x , x & y
and_expression	::= equality_expression
				| and_expression AND equality_expression;

// eg: int: x = 2 , default: x = 2
generic_association	::= type_name COLON assignment_expression
					| DEFAULT COLON assignment_expression;

// eg: x , x == 0 , x != 12
equality_expression	::= relational_expression
					| equality_expression EQ_OP relational_expression
					| equality_expression NE_OP relational_expression;

// eg: x , x < 2 , x > a , x <= 12 , x >= b
relational_expression	::= shift_expression
						| relational_expression LE shift_expression
						| relational_expression GE shift_expression
						| relational_expression LE_OP shift_expression
						| relational_expression GE_OP shift_expression;

// eg: x , x << 2 , x >> a
shift_expression	::= additive_expression
					| shift_expression LEFT_OP additive_expression
					| shift_expression RIGHT_OP additive_expression;

// eg: x , x + 2 , x - 3
additive_expression	::= multiplicative_expression
					| additive_expression ADD multiplicative_expression
					| additive_expression SUB multiplicative_expression;

// eg: x , x * 2 , x / a , x % 5
multiplicative_expression	::= cast_expression
							| multiplicative_expression MUL cast_expression
							| multiplicative_expression DIV cast_expression
							| multiplicative_expression MOD cast_expression;