import java_cup.runtime.*;
import model.*;
import util.ListUtils;
import util.Logger;
import codegen.CodeEngine;
import java.util.ArrayList;

parser code {:
  private Semantic semanticAnalyser = new Semantic();
  private CodeEngine codeEngine = new CodeEngine();

  public parser(java.io.Reader input) {
  	super(new Lexer(input));
  }

  public String toAssemblyCode() {
    return codeEngine.toAssemblyString();
  }

  /* Change the method syntax_error so when it reports a syntax
     error it will foward the problematic symbol to report_error.*/
  public void syntax_error(java_cup.runtime.Symbol cur_token) {
  	report_error("Syntax error", cur_token);
  }

  public void unrecovered_syntax_error(java_cup.runtime.Symbol cur_token) {
	report_fatal_error("Syntax error, couldn't repair and continue parse", cur_token);
  }


  /* Change the method report_error so it will display the line and
     column of where the error occurred in the input as well as the
     reason for the error which is passed into the method in the
     String 'message'. It will differ between type of error. */
  public void report_error(String message, Object info) {
  	/* Create a StringBuilder called 'm' with the string 'Error' in it. */
  	StringBuilder m = new StringBuilder("Error");

  	/* Check if the information passed to the method is the same
  	   type as the type java_cup.runtime.Symbol. */
  	if (info instanceof java_cup.runtime.Symbol) {
  		/* Declare a java_cup.runtime.Symbol object 's' with the
  		   information in the object info that is being typecasted
  		   as a java_cup.runtime.Symbol object. */
  		java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

  		/* Check if the line number in the input is greater or
  		   equal to zero. */
  		if (s.left >= 0) {
  			/* Add to the end of the StringBuilder error message
  			   the line number of the error in the input. */
  			m.append(" in line " + (s.left + 1));
  			/* Check if the column number in the input is greater
  			   or equal to zero. */
  			if (s.right >= 0)
  				/* Add to the end of the StringBuilder error message
  				   the column number of the error in the input. */
  				m.append(", column " + (s.right + 1));
  		}
  	}
	
  	/* Add to the end of the StringBuilder error message created in
  	   this method the message that was passed into this method. */
  	m.append(" : " + message);
  	/* Print the contents of the StringBuilder 'm', which contains
  	   an error message, out on a line. */
  	System.err.println(m);
  }

  /* Change the method report_fatal_error so when it reports a fatal
     error it will display the line and column number of where the
     fatal error occurred in the input as well as the reason for the
     fatal error which is passed into the method in the object
     'message' and then exit.*/
  public void report_fatal_error(String message, Object info) {
  	report_error(message, info);
  	System.exit(1);
  }
:};

init with	{:	codeEngine.initialize();
				Logger.println("<begin>");	:};

// Terminals (tokens returned by the scanner)
terminal	IDENTIFIER;
terminal	ENUMERATION_CONSTANT;
terminal	TYPEDEF_NAME;

terminal	AUTO;
terminal	BREAK;
terminal	CASE;
terminal	CHAR;
terminal	CONST;
terminal	CONTINUE;
terminal	DEFAULT;
terminal	DO;
terminal	DOUBLE;
terminal	ELSE;
terminal	ENUM;
terminal	EXTERN;

terminal	FLOAT;
terminal	FOR;
terminal	GOTO;
terminal	IF;
terminal	INLINE;
terminal	INT;
terminal	LONG;
terminal	REGISTER;
terminal	RESTRICT;
terminal	RETURN;
terminal	SHORT;

terminal	SIGNED;
terminal	SIZEOF;
terminal	STATIC;
terminal	STRUCT;
terminal	SWITCH;
terminal	TYPEDEF;
terminal	UNION;
terminal	UNSIGNED;
terminal	VOID;
terminal	VOLATILE;
terminal	WHILE;

terminal	ALIGNAS;
terminal	ALIGNOF;
terminal	ATOMIC;
terminal	BOOL;
terminal	COMPLEX;
terminal	GENERIC;
terminal	IMAGINARY;
terminal	NORETURN;
terminal	STATIC_ASSERT;
terminal	THREAD_LOCAL;

terminal	FUNC_NAME;
terminal	I_CONSTANT;
terminal	F_CONSTANT;
terminal	STRING_LITERAL;

terminal	ELLIPSIS;		// ...
terminal	RIGHT_ASSIGN;	// >>=
terminal	LEFT_ASSIGN;	// <<=
terminal	ADD_ASSIGN;		// +=
terminal	SUB_ASSIGN;		// -=
terminal	MUL_ASSIGN;		// *=
terminal	DIV_ASSIGN;		// /=
terminal	MOD_ASSIGN;		// %=
terminal	AND_ASSIGN;		// &=
terminal	XOR_ASSIGN;		// ^=
terminal	OR_ASSIGN;		// |=
terminal	RIGHT_OP;		// >>
terminal	LEFT_OP;		// <<
terminal	INC_OP;			// ++
terminal	DEC_OP;			// --
terminal	PTR_OP;			// ->
terminal	AND_OP;			// &&
terminal	OR_OP;			// ||
terminal	LE_OP;			// <=
terminal	GE_OP;			// >=
terminal	EQ_OP;			// ==
terminal	NE_OP;			// !=

terminal	SEMICOLON;	// ;
terminal	LCURLY;		// {
terminal	RCURLY;		// }
terminal	COMMA;		// ,
terminal	COLON;		// :
terminal	ASSIGN;		// =
terminal	LPAREN;		// (
terminal	RPAREN;		// )
terminal	LBRACKET;	// [
terminal	RBRACKET;	// ]
terminal	DOT;		// .
terminal	AND;		// &
terminal	NE;			// !
terminal	COMPLEMENT;	// ~
terminal	SUB;		// -
terminal	ADD;		// +
terminal	MUL;		// *
terminal	DIV;		// /
terminal	MOD;		// %
terminal	LE;			// <
terminal	GE;			// >
terminal	XOR;		// ^
terminal	OR;			// |
terminal	QUESTION;	// ?

// Nonterminals
non terminal translation_unit, external_declaration, function_definition, declaration_list, primary_expression;
non terminal constant, enumeration_constant, string, generic_selection, generic_assoc_list, generic_association;
non terminal postfix_expression, argument_expression_list, unary_expression, unary_operator, cast_expression;
non terminal multiplicative_expression, additive_expression, shift_expression, relational_expression;
non terminal equality_expression, and_expression, exclusive_or_expression, inclusive_or_expression;
non terminal logical_and_expression, logical_or_expression, conditional_expression, assignment_expression;
non terminal assignment_operator, expression, constant_expression, declaration, declaration_specifiers;
non terminal init_declarator_list, init_declarator, storage_class_specifier, type_specifier, struct_or_union_specifier;
non terminal struct_or_union, struct_declaration_list, struct_declaration, specifier_qualifier_list, struct_declarator_list;
non terminal struct_declarator, enum_specifier, enumerator_list, enumerator, atomic_type_specifier, type_qualifier;
non terminal function_specifier, alignment_specifier, declarator, direct_declarator, pointer, type_qualifier_list;
non terminal parameter_type_list, parameter_type_list_opt, parameter_list, parameter_declaration, identifier_list, type_name, abstract_declarator;
non terminal direct_abstract_declarator, initializer, initializer_list, designation, designator_list, designator;
non terminal static_assert_declaration, statement, labeled_statement, compound_statement, block_item_list;
non terminal block_item, expression_statement, selection_statement, iteration_statement, jump_statement;

precedence nonassoc ELSE;
precedence nonassoc ATOMIC;

start with translation_unit;

// The source file with #includes, #defines and all external declarations.
// eg: #include<stdio.h> int main() {printf("Hello, World!");}
// TODO
translation_unit	::= external_declaration				{:	Logger.println("translation_unit ::= external_declaration");	:}
					| translation_unit external_declaration	{:	Logger.println("translation_unit ::= translation_unit external_declaration");	:};

// At the top level of a translation unit, every C program is a sequence
// of declarations, which declare functions and objects with external 
// linkage. These declarations are known as external declarations because 
// they appear outside of any function.
// eg: int g = 32; , int main() {printf("Hello, World!");} , 
// int i = 40; int main() {printf("%d", i);}
// TODO
external_declaration	::= function_definition	{:	Logger.println("external_declaration ::= function_definition");	:}
						| declaration			{:	Logger.println("external_declaration ::= declaration");	:};

// A function definition associates the function body (a sequence of declarations and 
// statements) with the function name and parameter list. Unlike function declaration, 
// function definitions are allowed at file scope only (there are no nested functions).
// eg: int f(int a, int b) {return a + b;} , int f(a, b) int a, b; {return a + b;}
// TODO
function_definition	::= declaration_specifiers declarator declaration_list compound_statement			{:	Logger.println("function_definition ::= declaration_specifiers declarator declaration_list compound_statement");	:}
					| declaration_specifiers:t IDENTIFIER:id LPAREN parameter_type_list_opt:pl RPAREN	{:	semanticAnalyser.validateFunction((String) id,(ArrayList<Parameter>) pl,(Type)t);
																											codeEngine.functionDeclarationBegin((String) id, (ArrayList<Parameter>) pl, (Type) t);
																											Logger.println("function_definition ::=  declaration_specifiers IDENTIFIER LPAREN parameter_type_list_opt RPAREN <begin>");	:}
					compound_statement:st																{:	if (st instanceof Expression) {
																												semanticAnalyser.exitCurrentScope((Expression) st);
																											} else { 
																												semanticAnalyser.exitCurrentScope();
																											}	
																											codeEngine.functionDeclarationEnd();
																											Logger.println("function_definition ::=	declaration_specifiers IDENTIFIER LPAREN parameter_type_list_opt RPAREN <end>");	:};

parameter_type_list_opt ::=							{:	Logger.println("parameter_type_list_opt ::=	<empty>");	:}
						| parameter_type_list:pl	{:	RESULT = pl;
														Logger.println("parameter_type_list_opt ::=	parameter_type_list");	:};

// A declaration is a C language construct that introduces one or more identifiers 
// into the program and specifies their meaning and properties. The enum, struct, 
// and union declarations may omit declarators. Can be a static-assert declaration.
// eg: enum COLOR {RED, GREEN, BLUE}; , const int *f(void); , int a, *b=NULL; ,
// _Static_assert(2 + 2 == 4, "Whoa dude!");
// TODO
declaration	::= declaration_specifiers:t SEMICOLON						{:	semanticAnalyser.commitDeclaredVariables((Type) t);
																			Logger.println("declaration ::=	declaration_specifiers SEMICOLON");	:}
			| declaration_specifiers:t init_declarator_list:v SEMICOLON	{:	semanticAnalyser.commitDeclaredVariables((Type) t);
																			Logger.println("declaration ::=	declaration_specifiers init_declarator_list SEMICOLON");	:}
			| static_assert_declaration									{:	Logger.println("declaration ::=	static_assert_declaration");	:};

// Whitespace-separated list of, in any order, one type specifier like void, arithmetic
// or atomic types; zero or one storage-class specifiers: typedef, auto, register, static, 
// extern, thread_local; zero or more type qualifiers: const, volatile, restrict, _Atomic;
// (only when declaring functions), zero or more function specifier: inline, noreturn;
// zero or more alignment specifiers: alignas.
// eg: typedef static , static , int static , int , const static , const , 
// inline const , inline , _Alignas() static , _Alignas()
// TODO
declaration_specifiers	::= storage_class_specifier declaration_specifiers:t	{:	RESULT = t;
																					Logger.println("declaration_specifiers ::=	storage_class_specifier declaration_specifiers");	:}
						| storage_class_specifier								{:	Logger.println("declaration_specifiers ::=	storage_class_specifier");	:}
						| type_specifier:t declaration_specifiers				{:	RESULT = t;
																					Logger.println("declaration_specifiers ::=	type_specifier declaration_specifiers");	:}
						| type_specifier:t										{:	RESULT = t; 
																					Logger.println("declaration_specifiers ::=	type_specifier");	:}
						| type_qualifier declaration_specifiers:t				{:	RESULT = t;
																					Logger.println("declaration_specifiers ::=	type_qualifier declaration_specifiers");	:}
						| type_qualifier										{:	Logger.println("declaration_specifiers ::=	type_qualifier");	:}
						| function_specifier declaration_specifiers				{:	Logger.println("declaration_specifiers ::=	function_specifier declaration_specifiers");	:}
						| function_specifier									{:	Logger.println("declaration_specifiers ::=	function_specifier");	:}
						| alignment_specifier declaration_specifiers			{:	Logger.println("declaration_specifiers ::=	alignment_specifier declaration_specifiers");	:}
						| alignment_specifier									{:	Logger.println("declaration_specifiers ::=	alignment_specifier");	:};

// Provides type information and/or the identifier to declare, can be a
// pointer declaration: the declaration S * cvr D; declares D as a 
// cvr-qualified pointer to the type determined by S.
// eg: a , *b , *f(void) , *f(int i, int a)
// TODO
declarator	::= pointer direct_declarator	{:	Logger.println("declarator ::=	pointer direct_declarator");	:}
			| direct_declarator:v 			{:	RESULT = v;
												Logger.println("declarator ::=	direct_declarator");	:};

// Set of declarations in sequence.
// eg: int i = 0; int j = 1 , char c;
// TODO
declaration_list	::= declaration					{:	Logger.println("declaration_list ::=	declaration");	:}
					| declaration_list declaration	{:	Logger.println("declaration_list ::=	declaration_list declaration");	:};

// A compound statement, or block, is a brace-enclosed sequence of statements and declarations.
// eg: {} , { int i = 0; } , {int i = 0; printf(i++); printf(i++);}
// TODO
compound_statement	::= LCURLY RCURLY					{:	Logger.println("compound_statement ::=	LCURLY RCURLY");	:}
					| LCURLY block_item_list:st RCURLY	{: 	RESULT = st;
															Logger.println("compound_statement ::=	LCURLY block_item_list RCURLY");	:};


// Comma-separated list of declarators (each declarator provides additional 
// type information and/or the identifier to declare).
// eg: c = 3, i = 2 , *x = &i, *y = &j , a = 1
// TODO
init_declarator_list	::= init_declarator:v 							{:	RESULT = v;
																			Logger.println("init_declarator_list ::=	init_declarator");	:}
						| init_declarator_list COMMA init_declarator:v	{:	RESULT = v;
																			Logger.println("init_declarator_list ::=	init_declarator_list COMMA init_declarator");	:};

// All keywords or expressions that represents the type of a value: can be void, an
// an arithmetic type, an atomic type, a name earlier introduced by a typedef declaration,
// struct, union, or enum specifier.
// eg: void , char , short , int , long , float , double , signed , unsigned ,
// bool , _Complex , _Imaginary , _Atomic(int) , enum{ML, MN} , Retangle
// TODO
type_specifier	::= VOID					{:	RESULT = new Type("void");	:}
				| CHAR						{:	RESULT = new Type("char");	:}
				| SHORT						{:	RESULT = new Type("short");	:}
				| INT:i						{:	RESULT = new Type("int");	:}
				| LONG						{:	RESULT = new Type("long");	:}
				| FLOAT						{:	RESULT = new Type("float");	:}
				| DOUBLE					{:	RESULT = new Type("double");	:}
				| SIGNED					{:	RESULT = new Type("signed");	:}
				| UNSIGNED					{:	RESULT = new Type("unsigned");	:}
				| BOOL						{:	RESULT = new Type("bool");	:}
				| COMPLEX 
				| IMAGINARY  
				| atomic_type_specifier
				| struct_or_union_specifier
				| enum_specifier
				| TYPEDEF_NAME;

// Provide type information and/or identifier to declare. Can be the identifier
// that this declarator introduces; any declarator may be enclosed in parentheses;
// can be an array declarator: the declaration S D[N] declares D as an array of N 
// objects of the type determined by S; can be function declarator: the 
// declaration S D(params) declared D as a function taking the parameters params 
// and returning S.
// eg: x , (x) , (*obj), m[] , m[*] , m[20] , x[i = 0], x(int, int) , x(), 
// x(a, b, c)
// TODO
direct_declarator	::= IDENTIFIER:id																		{:	RESULT = id;	:}
					| LPAREN declarator RPAREN
					| direct_declarator LBRACKET RBRACKET
					| direct_declarator LBRACKET MUL RBRACKET
					| direct_declarator LBRACKET STATIC type_qualifier_list assignment_expression RBRACKET
					| direct_declarator LBRACKET STATIC assignment_expression RBRACKET
					| direct_declarator LBRACKET type_qualifier_list MUL RBRACKET
					| direct_declarator LBRACKET type_qualifier_list STATIC assignment_expression RBRACKET
					| direct_declarator LBRACKET type_qualifier_list assignment_expression RBRACKET
					| direct_declarator LBRACKET type_qualifier_list RBRACKET
					| direct_declarator LBRACKET assignment_expression RBRACKET
					| direct_declarator:id LPAREN parameter_type_list:parameter_list RPAREN
					| direct_declarator LPAREN RPAREN
					| direct_declarator LPAREN identifier_list RPAREN;

// Set of declarations and statements at sequence.
// eg: int i = 0; , int i = 0; printf(i++); printf(i++);
// TODO
block_item_list	::= block_item:st				{:	RESULT = st;	:}
				| block_item_list block_item:st	{:	RESULT = st;	:};

// Declarators may be accompanied by initializers. The enum, struct, and union 
// declarations may omit declarators, in which case they only introduce 
// the enumeration constants and/or tags.
// eg: *x = &a, c = 3 , c , *f(void) = &calc
// TODO
init_declarator	::= declarator:id ASSIGN initializer:ep	{:	Variable v = new Variable((String) id, new Type("null"), (Expression) ep);
															semanticAnalyser.addScopedVar(v);
															codeEngine.generateAttribution((String) id, ep);
															RESULT = v;	:}
				| declarator:id							{:	Variable v = new Variable((String) id, new Type("null"));
															semanticAnalyser.addScopedVar(v);
															RESULT = v;	:};

// Constant values of certain types may be embedded in the source code of a 
// C program using specialized expressions known as literals (for lvalue
// expressions) and constants (for non-lvalue expressions).
// eg: 12, 14, 3.14
// TODO
constant_expression	::= conditional_expression:ep {: RESULT=ep; :};

// Here we defined the 14º precedence on operators in C, the assignment and 
// compound assignment operators that are binary operators that modify the 
// variable to their left using the value to their right.
// eg: x , a + b , i++ , x++ = a + b , a += m , i *= 2
// TODO
assignment_expression	::= conditional_expression:e											{:	Logger.println("assignment_expression ::=	conditional_expression");
																									RESULT=e;	:}
						| unary_expression:id assignment_operator:op assignment_expression:e	{:	Logger.println("assignment_expression ::=	unary_expression assignment_operator assignment_expression");
																									Variable var;
																									if (id instanceof String) {
                                                    													semanticAnalyser.checkVariableAttribution((String) id, (Expression) e);
																										var = semanticAnalyser.findVariableByIdentifier((String) id);
																										var.setValue((Expression) e);
																										RESULT = e;
																									} else {
																										RESULT = e;
                                                    												}
																									codeEngine.generateAttribution((String) id, (Operation) op, (Expression) e);	:};

// Either the single keyword void or a comma-separated list of parameters, 
// which may end with an ellipsis parameter.
// eg: int x, int y, ... , int x
// TODO
parameter_type_list	::= parameter_list COMMA ELLIPSIS
					| parameter_list:pl					{:	RESULT = pl;	:};

// Block item, it's a declaration or a statement.
// eg: int i = 0; , f(1, 3); , printf("Oi");
// TODO
block_item	::= declaration
			| statement:st	{:	RESULT = st;	:};

// A declaration of an object may provide its initial value through the 
// process known as initialization. For each declarator, the initializer, 
// if not omitted, may be a expression, or a initializer-list.
// eg: {[0].a = {1}, [1].a[0] = 2} , {1, 2, 3,} , x + a , 12.2 , "oi"
// TODO
initializer	::= LCURLY initializer_list RCURLY
			| LCURLY initializer_list COMMA RCURLY
			| assignment_expression:ep				{:	RESULT=ep;	:};

// Here we defined the 13º precedence on operators in C, the ternary conditional "?:",
// which allows to create a mini if-then-else calculation. Note the restriction on the values to
// be evaluated as bool or not, and the else value.
// eg: x , a + b , i++ , x > 2 ? 12 : x + 12 , condition ? i += 2 : condition2 ? j += 2 : 0
// TODO
conditional_expression	::= logical_or_expression:ep												{:	RESULT = ep;	:}
						| logical_or_expression QUESTION expression COLON conditional_expression;

// Here we defined the rest of the operators at 2º precedence in C, unary
// operators like "i++" or "!(x >= 2)", they only are applied when put 
// right before the expression, "prefixed" to the expression to change. 
// It's used to execute various operations in C, but it affects only one 
// expression at a time.
// eg: x , s[i] , ++x , --x , -b , *b , ~2 , !(a || b) , *(int) x , 
// sizeof x , sizeof(int) , _Alignof(int)
// TODO
unary_expression	::= postfix_expression:ep				{:	RESULT = ep; :}
					| INC_OP unary_expression
					| DEC_OP unary_expression
					| unary_operator:op cast_expression:re	{:	semanticAnalyser.validateExpressionType(new Type("int"), (Expression) re); 
																RESULT = semanticAnalyser.getExpression((Expression) re, (Operation) op, (Expression) re);
																codeEngine.operation((Expression) RESULT, (Expression) re, (Operation) op, (Expression) re);	:}
					| SIZEOF unary_expression
					| SIZEOF LPAREN type_name RPAREN
					| ALIGNOF LPAREN type_name RPAREN;

// All assignment operators on C. Besides the assignment function
// some executes different operations related to the value that
// existed before the assignment.
// eg: = , *= , /= , %= , += , -= , <<= , >>= , &= , ^= , |=
// TODO
assignment_operator	::= ASSIGN 		{:	RESULT = Operation.valueOf("EQ");	:}
					| MUL_ASSIGN 	{:	RESULT = Operation.valueOf("MULTEQ");	:}
					| DIV_ASSIGN	{:	RESULT = Operation.valueOf("DIVEQ");	:}
					| MOD_ASSIGN	{:	RESULT = Operation.valueOf("MODEQ");	:}
					| ADD_ASSIGN	{:	RESULT = Operation.valueOf("PLUSEQ");	:}
					| SUB_ASSIGN	{:	RESULT = Operation.valueOf("MINUSEQ");	:}
					| LEFT_ASSIGN	{:	RESULT = Operation.valueOf("LTLTEQ");	:}
					| RIGHT_ASSIGN	{:	RESULT = Operation.valueOf("GTGTEQ");	:}
					| AND_ASSIGN	{:	RESULT = Operation.valueOf("ANDEQ");	:}
					| XOR_ASSIGN	{:	RESULT = Operation.valueOf("XOREQ");	:}
					| OR_ASSIGN		{:	RESULT = Operation.valueOf("OREQ");	:};

// Comma-separated list of parameters.
// eg: int x , int x, int y , int, char
// TODO
parameter_list	::= parameter_declaration:p							{:	RESULT = ListUtils.newList(p);	:}
				| parameter_list:pl COMMA parameter_declaration:p	{:	((ArrayList<Parameter>) pl).add(0, (Parameter) p); 
																		RESULT = pl;	:};

// Statements are fragments of the C program that are executed in sequence. 
// The body of any function is a compound statement, which, in turn is a 
// sequence of statements and declarations.
// eg: i = 2*b; , if(i > 0) i = -1;
// TODO
statement	::= labeled_statement
			| compound_statement
			| expression_statement
			| selection_statement
			| iteration_statement
			| jump_statement:st		{:	RESULT = st;	:};

// A initializer-list is a non-empty comma-separated list of initializers (with 
// an optional trailing comma), where each initializer has one of three 
// possible forms: expression, {initializer_list} or designator_list = expression.
// eg: [0].a = {1} , x , 12 , [0].a = {1}, [1].a[0] = 2 , 1, 2, 3
// TODO
initializer_list	::= designation initializer
					| initializer
					| initializer_list COMMA designation initializer
					| initializer_list COMMA initializer;

// Here we defined the 12º precedence on operators in C, the logical or "||".
// It's used to evaluate bool values on the conditions in C.
// eg: x , a + b , x || a , a || b || c , a || b && c
// TODO
logical_or_expression	::= logical_and_expression:ep								{:	Logger.println("logical_or_expression ::= logical_and_expression");
																						RESULT = ep;	:}
						| logical_or_expression:le OR_OP logical_and_expression:re	{:	Logger.println("logical_or_expression ::= logical_or_expression OR_OP logical_and_expression");
																						RESULT = semanticAnalyser.getExpression((Expression) le, Operation.valueOf("OROR"), (Expression) re);
																						codeEngine.operation((Expression) RESULT, (Expression) le, Operation.valueOf("OROR"), (Expression) re);	:};

// An expression is a sequence of operators and their operands, that specifies a
// computation. Expression evaluation may produce a result (e.g., evaluation of
// 2+2 produces the result 4), may generate side-effects (e.g. evaluation of 
// printf("%d",4) sends the character '4' to the standard output stream), and 
// may designate objects or functions.
// eg: x , a = 2 , a + b , a + (-b) , x, a = 2
// TODO
expression	::= assignment_expression:ep {: RESULT=ep; :}
			| expression COMMA assignment_expression;

// Here we defined the operators at 1º precedence in C, postfix operators 
// like "a[i]" or "calc()", they only are applied when put right after the 
// expression, "postfixed" to the expression to change.
// It's used to execute plenty things in C, affecting only one expression
// at a time. They are related to value addressing, and function execution, 
// hence the high priority.
// eg: x , x(20) , f() , f(a = 2, b = 3) , x.a , x->a , x++ , x-- , 
// (Retangle){a = 2} , {Retangle}{a = 2,}
// TODO
postfix_expression	::= primary_expression:ep											{:	RESULT = ep;	:}
					| postfix_expression LBRACKET expression RBRACKET
					| postfix_expression:id LPAREN RPAREN								{:	FunctionCall fc = new FunctionCall((String) id); 
																							semanticAnalyser.verifyFunctionCall(fc);
																							RESULT = fc;	:}
					| postfix_expression:id LPAREN argument_expression_list:args RPAREN	{:	FunctionCall fc = null;
                                                                                			if(args != null){
                                                                                  				ArrayList<Expression> list = new ArrayList<Expression>();
                                                                                  				try {
                                                                                      				list = ((ExpressionList) args).getExpressionList();
                                                                                      				fc = new FunctionCall((String) id, (ExpressionList) args);
                                                                                  				} catch (Exception except) {
                                                                                      				ExpressionList el = new ExpressionList((Expression) args);
                                                                                      				fc = new FunctionCall((String) id, el);
                                                                                  				}
                                                                              				} else {
                                                                                  				fc = new FunctionCall((String) id);
                                                                              				}

                                                                              				semanticAnalyser.verifyFunctionCall(fc);
                                                                              				RESULT = fc;	:}
					| postfix_expression DOT IDENTIFIER
					| postfix_expression PTR_OP IDENTIFIER
					| postfix_expression INC_OP
					| postfix_expression DEC_OP
					| LPAREN type_name RPAREN LCURLY initializer_list RCURLY
					| LPAREN type_name RPAREN LCURLY initializer_list COMMA RCURLY;

// All of prefixed unary operators on C. Perform various operations
// at number, logical or bitwise scope.
// eg: & , * , + , - , ~ , !
// TODO
unary_operator	::= AND
				| MUL
				| ADD
				| SUB
				| COMPLEMENT
				| NE			{:	RESULT = Operation.valueOf("NOT");	:};

// Here we defined one of the operators at 2º precedence in C, the cast
// operation like "(int) x" or "(float) 2 / 12". It's used to transform 
// values to different types in C.
// eg: x , a[i++] , (int) x , (float) 2 , (float) ++i
// TODO
cast_expression	::= unary_expression:ep 						{:	if (ep instanceof String) {
																		Variable v = semanticAnalyser.findVariableByIdentifier((String) ep);
																		if (v.getValue() != null) {
																			RESULT = v.getValue();
																		} else {
																			RESULT = new Expression((Type) v.getType(), (String) ep); //It's a parameter
																		}
																	} else {
																		RESULT = ep;
																	}	:}
				| LPAREN type_name RPAREN cast_expression:ep	{:	RESULT = ep;	:};

// A specific declaration, related to parameters on functions.
// eg: int x , int* , int[][] , int
// TODO
parameter_declaration	::= declaration_specifiers:t declarator:id		{:	Variable v = new Variable((String) id, (Type) t);
																			RESULT = v;	:}
						| declaration_specifiers abstract_declarator
						| declaration_specifiers;

// Any statement can be labeled, by providing a name followed by a colon 
// before the statement itself. It can be: target for a goto; case label in 
// a switch statement; or a default label in a switch statement.
// eg: begin: i = 0; , case 1: printf("End!"); , default: printf("Erro!");
// TODO
labeled_statement	::= IDENTIFIER COLON statement
					| CASE constant_expression COLON statement
					| DEFAULT COLON statement;

// An expression followed by a semicolon is a statement. Most statements in a 
// typical C program are expression statements, such as assignments or 
// function calls.
// eg: ; , x = 1; , f(1, 2); , x[0] = 12; , printf("Oi!");
// TODO
expression_statement	::= SEMICOLON
						| expression SEMICOLON;

// The selection statements choose between one of several statements depending 
// on the value of an expression.
// eg: if(x > 2) a = x; else a = y; , if(x > 2) a = x; , switch(x) a = x;
// TODO
selection_statement	::= IF LPAREN expression RPAREN statement ELSE statement
					| IF LPAREN expression RPAREN statement
					| SWITCH LPAREN expression:ep RPAREN statement {:  :};

// The jump statements unconditionally transfer flow control.
// eg: goto start; , continue; , break; , return; , return x + 1;
// TODO
jump_statement	::= GOTO IDENTIFIER SEMICOLON
				| CONTINUE SEMICOLON
				| BREAK SEMICOLON
				| RETURN SEMICOLON
				| RETURN expression:ep SEMICOLON	{:	Logger.println("jump_statement ::= RETURN expression SEMICOLON");
														((Expression) ep).setReturn(true); 
														codeEngine.returnExpression((Expression) ep);
														RESULT=ep;	:};

// Here we defined the 11º precedence on operators in C, the logical and "&&".
// It's used to evaluate bool values on the conditions in C.
// eg: x , a + b , a[i] , x && a , a && b && c , a && b && !c
logical_and_expression	::= inclusive_or_expression:ep									{:	Logger.println("logical_and_expression ::= inclusive_or_expression");
																							RESULT = ep;	:}
						| logical_and_expression:le AND_OP inclusive_or_expression:re	{:	Logger.println("logical_and_expression ::= logical_and_expression AND_OP inclusive_or_expression");
																							RESULT = semanticAnalyser.getExpression((Expression) le, Operation.valueOf("ANDAND"), (Expression) re);
																							codeEngine.operation((Expression) RESULT, (Expression) le, Operation.valueOf("ANDAND"), (Expression) re);	:};

// The operands of any operator may be other expressions or they may be 
// primary expressions (e.g. in 1+2*3, the operands of operator+ are the 
// subexpression 2*3 and the primary expression 1). Primary expressions 
// are any of the following: constants and literals (e.g. 2 or
// "Hello, world"); suitably declared identifiers (e.g. n or printf); 
// generic selections
// eg: x , a , b , 11 , 12.2 , 0xA2 , "oi" , "tchau" , "Hi, Leo!" , 
// (x >= 2) , (a == (i = j + i + 1)) , _Generic(x = 1, int: x = 2)
primary_expression	::= IDENTIFIER:id				{:	Logger.println("primary_expression ::= IDENTIFIER");
														RESULT = id;	:}
					| constant:c					{:	Logger.println("primary_expression ::= constant");
														RESULT = c;	:}
					| string:s						{:	Logger.println("primary_expression ::= string");
														RESULT = s;	:}
					| LPAREN expression:ep RPAREN	{:	Logger.println("primary_expression ::= LPAREN expression RPAREN");
														RESULT = ep;	:}
					| generic_selection;

// Comma-separated list of expressions (which cannot be comma operators) of 
// any complete object type. May be omitted when calling functions that take 
// no arguments.
// eg: x , x + 2, a , a, b, c * 2
argument_expression_list	::= assignment_expression:ep									{:	Logger.println("argument_expression_list ::= assignment_expression");
																								ExpressionList el = new ExpressionList((Expression) ep);
																								RESULT = el;	:}
							| argument_expression_list:epl COMMA assignment_expression:ep	{:	Logger.println("argument_expression_list ::= argument_expression_list COMMA assignment_expression");
																								((ExpressionList) epl).add((Expression)ep);
																								RESULT = epl;	:};

// Here we defined the 10º precedence on operators in C, the bitwise or "|".
// It's used to evaluate bitwise values in C.
// eg: x , a + b , a[i] , x | y , a | b | c , a ^ b & c , a << 2 | b
inclusive_or_expression	::= exclusive_or_expression:ep							{:	Logger.println("inclusive_or_expression ::= exclusive_or_expression");
																					RESULT = ep;	:}
						| inclusive_or_expression:le OR exclusive_or_expression:re {:   Logger.println("logical_or_expression ::= logical_or_expression OR_OP logical_and_expression");
                                                                                        RESULT = semanticAnalyser.getExpression((Expression) le, Operation.valueOf("OR"), (Expression) re);
                                                                                        codeEngine.operation((Expression) RESULT, (Expression) le, Operation.valueOf("OR"), (Expression) re); :};

// Constant values of certain types may be embedded in the source code of a C 
// program using specialized expressions known as literals (for lvalue 
// expressions) and constants (for non-lvalue expressions).
// eg: 1001 , 20.5 , 0xA3 , 0732 , MAX
constant	::= I_CONSTANT:c		{:	Logger.println("constant ::= I_CONSTANT");
										RESULT = new Expression(new Type("int"), c.toString());	:}
			| F_CONSTANT:c			{:	Logger.println("constant ::= F_CONSTANT");
										RESULT = new Expression(new Type("float"), c.toString());	:}
			| ENUMERATION_CONSTANT;

// Constructs an unnamed object of specified character array type in-place, 
// used when a character string needs to be embedded in source code.
// eg: "oi" , "Hi, Dênnis!" , __func__
string	::= STRING_LITERAL:s	{:	Logger.println("string ::= STRING_LITERAL");
									Expression ep = new Expression(new Type("char"),(String) s);
									RESULT = ep;	:}
		| FUNC_NAME;

// Here we defined the 9º precedence on operators in C, the bitwise 
// exclusive or "^". It's used to evaluate bitwise values in C.
// eg: x , a + b , a[i] , x ^ y , x ^ y && b , a ^ b ^ c
exclusive_or_expression	::= and_expression:ep							{:	Logger.println("exclusive_or_expression ::= and_expression");
																			RESULT = ep;	:}
						| exclusive_or_expression:le XOR and_expression:re {:   Logger.println("logical_or_expression ::= logical_or_expression OR_OP logical_and_expression");
                                                                                        RESULT = semanticAnalyser.getExpression((Expression) le, Operation.valueOf("XOR"), (Expression) re);
                                                                                        codeEngine.operation((Expression) RESULT, (Expression) le, Operation.valueOf("XOR"), (Expression) re); :};

// Here we defined the 8º precedence on operators in C, the bitwise and "&". 
// It's used to evaluate bitwise values in C.
// eg: x , a + b , x[i] , x & y , x & y & c , a << 2 & c
and_expression	::= equality_expression:ep					{:	Logger.println("and_expression ::= equality_expression");
																RESULT = ep;	:}
				| and_expression:le AND equality_expression:re {:   Logger.println("logical_or_expression ::= logical_or_expression OR_OP logical_and_expression");
                                                                                        RESULT = semanticAnalyser.getExpression((Expression) le, Operation.valueOf("AND"), (Expression) re);
                                                                                        codeEngine.operation((Expression) RESULT, (Expression) le, Operation.valueOf("AND"), (Expression) re); :};

// Here we defined the 7º precedence on operators in C, the equality operators.
// "==" and "!=". It's used to evaluate boolean values in C.
// eg: x , a + b , x == 0 , x != 12 , a >= 2 , i - 2 == 3
equality_expression	::= relational_expression:ep						{:	Logger.println("equality_expression ::= relational_expression");
																			RESULT = ep;	:}
					| equality_expression EQ_OP relational_expression
					| equality_expression NE_OP relational_expression;

// Here we defined the 6º precedence on operators in C, the relational operators.
// It's used to evaluate boolean values in C.
// eg: x , a + b , a[i] , x < 2 , x > a , x <= 12 , x >= b
relational_expression	::= shift_expression:ep							{:	Logger.println("relational_expression ::= shift_expression");
																			RESULT = ep;	:}
						| relational_expression LE shift_expression
						| relational_expression GE shift_expression
						| relational_expression LE_OP shift_expression
						| relational_expression GE_OP shift_expression;

// Here we defined the 5º precedence on operators in C, the shift operators.
// It's used to evaluate bitwise values in C, or calculate exponential with 2
// as a base.
// eg: x , a + b , a[i] , x << 2 , x >> a
shift_expression	::= additive_expression:ep							{:	Logger.println("shift_expression ::= additive_expression");
																			RESULT = ep;	:}
					| shift_expression LEFT_OP additive_expression
					| shift_expression RIGHT_OP additive_expression;

// Here we defined the 4º precedence on operators in C, the addition operators.
// It's used to evaluate numbers values in C, in addition or subtraction.
// eg: x , a[i] , x + 2 , x - 3 , x*2 + 3
additive_expression	::= multiplicative_expression:ep							{:	Logger.println("additive_expression ::= multiplicative_expression");
																					RESULT = ep;	:}
					| additive_expression:le ADD multiplicative_expression:re	{:	Logger.println("additive_expression ::= additive_expression ADD multiplicative_expression");
																					RESULT = semanticAnalyser.getExpression((Expression) le, Operation.valueOf("PLUS"), (Expression) re);
																					codeEngine.operation((Expression) RESULT, (Expression) le, Operation.valueOf("PLUS"), (Expression) re);	:}
					| additive_expression:le SUB multiplicative_expression:re	{:	Logger.println("additive_expression ::= additive_expression SUB multiplicative_expression");
																					RESULT = semanticAnalyser.getExpression((Expression) le, Operation.valueOf("MINUS"), (Expression) re);
																					codeEngine.operation((Expression) RESULT, (Expression) le, Operation.valueOf("MINUS"), (Expression) re);	:};

// Here we defined the 3º precedence on operators in C, the multiplicative
// operators like "*", "/" and "%". It's used to evaluate numbers values in
// C, in multiplication or remainder calculation.
// eg: x , x * 2 , x / a , x % 5 , 2*x++
multiplicative_expression	::= cast_expression:ep									{:	Logger.println("multiplicative_expression ::= cast_expression");
																						RESULT = ep;	:}
							| multiplicative_expression:le MUL cast_expression:re	{:	Logger.println("multiplicative_expression ::= multiplicative_expression MUL cast_expression");
																						RESULT = semanticAnalyser.getExpression((Expression) le, Operation.valueOf("MULT"), (Expression) re);
																						codeEngine.operation((Expression) RESULT, (Expression) le, Operation.valueOf("MULT"), (Expression) re);	:}
							| multiplicative_expression:le DIV cast_expression:re	{:	Logger.println("multiplicative_expression ::= multiplicative_expression DIV cast_expression");
																						RESULT = semanticAnalyser.getExpression((Expression) le, Operation.valueOf("DIV"), (Expression) re);
																						codeEngine.operation((Expression) RESULT, (Expression) le, Operation.valueOf("DIV"), (Expression) re);	:}
							| multiplicative_expression:le MOD cast_expression:re	{:	Logger.println("multiplicative_expression ::= multiplicative_expression MOD cast_expression");
																						RESULT = semanticAnalyser.getExpression((Expression) le, Operation.valueOf("MOD"), (Expression) re);
																						codeEngine.operation((Expression) RESULT, (Expression) le, Operation.valueOf("MOD"), (Expression) re);	:};


// Known but unnecessary rules for semantics.
// These rules are completely outside our scope. We can ignore them without problems.

// Assignment of a designator_list, that usualy it's inside a declaration.
// eg: [i][j] = , [x].a = , .left.left =
designation	::= designator_list ASSIGN;

// Designator-list is a list of either array designators of the form 
// [constant-expression] or struct/union member designators of the form
// .identifier ;
// eg: [i] , [i][j] , .left.left
designator_list	::= designator
				| designator_list designator;

// It specifies an adress related to the Identifier, like in
// ball[12] or ball.radius.
// eg: [i] , [12] , .radius
designator	::= LBRACKET constant_expression RBRACKET
			| DOT IDENTIFIER;

// Storage-class specifiers appear in declarations. At most one specifier may be 
// used, except that _Thread_local may be combined with static or extern to adjust
// linkage. The storage-class specifiers determine two independent properties of 
// the names they declare: storage duration and linkage.
// eg: typedef , extern , static , _Thread_local , auto , register
storage_class_specifier ::= TYPEDEF
						| EXTERN
						| STATIC
						| THREAD_LOCAL
						| AUTO
						| REGISTER;

// Each individual type in the C type system has several qualified versions of 
// that type, corresponding to one, two, or all four of the const, volatile, _Atomic, 
// and, for pointers to object types, restrict qualifiers.
// eg: const , restrict , volatile , _Atomic
type_qualifier	::= CONST
				| RESTRICT
				| VOLATILE
				| ATOMIC;

// Function specifiers appear in declarations. They can be used together, serving 
// as a hint for the compiler to perform optimizations, such as function inlining.
// eg: inline , _Noreturn
function_specifier	::= INLINE
					| NORETURN;

// Pointer is a type of an object that refers to a function or an object of 
// another type, possibly adding qualifiers. Pointer may also refer to nothing,
// which is indicated by the special null pointer value.
// eg: *p, **p , * const pc , * const * pc , ** , * 
pointer	::= MUL type_qualifier_list pointer
		| MUL type_qualifier_list
		| MUL pointer
		| MUL;

// Defines an abstract data type, with struct or union.
// eg: struct {} , struct Retangle {} , struct Retangle
struct_or_union_specifier	::= struct_or_union LCURLY struct_declaration_list RCURLY
							| struct_or_union IDENTIFIER LCURLY struct_declaration_list RCURLY
							| struct_or_union IDENTIFIER;

// An enumerated type is a distinct type whose value is a value of its 
// underlying type, which includes the values of explicitly named constants 
// (enumeration constants).
// eg: enum{RED, GREEN, BLUE} , enum{RED = -1, GREEN, BLUE,} , 
// enum colors{RED, GREEN, BLUE}
enum_specifier	::= ENUM LCURLY enumerator_list RCURLY
				| ENUM LCURLY enumerator_list COMMA RCURLY
				| ENUM IDENTIFIER LCURLY enumerator_list RCURLY
				| ENUM IDENTIFIER LCURLY enumerator_list COMMA RCURLY
				| ENUM IDENTIFIER;

// List of keywords changing the aspect of a value.
// eg: const , volatile const
type_qualifier_list	::= type_qualifier
					| type_qualifier_list type_qualifier;

// A set of names that defines the type of a value.
// eg: int[] , int (*int, *int) , char[30] , *void() , int, long int
type_name	::= specifier_qualifier_list abstract_declarator
			| specifier_qualifier_list;

// Comma-separated list of identifiers (only if this declarator is used as 
// part of old-style function definition), must be omitted for old-style 
// declarations that are not definitions.
// eg: x , x, a, b
identifier_list	::= IDENTIFIER
				| identifier_list COMMA IDENTIFIER;

// Keywords that enable creation of abstract data types.
// eg: struct , union
struct_or_union ::= STRUCT
				| UNION;

// Any number of variable declarations, bit field declarations, and static assert 
// declarations. Members of incomplete type and members of function type are not 
// allowed.
// eg: int i, j; , int x; char *c;
struct_declaration_list	::= struct_declaration
						| struct_declaration_list struct_declaration;

// Enumerator-list is a comma-separated list (with trailing comma permitted) 
// (since C99) of enumerators, each of which has the form: enumerator = 
// constant-expression, where enumerator are identifiers introduced by this 
// declaration.
// eg: RED, GREEN, BLUE , RED = -1, GREEN, BLUE
enumerator_list	::= enumerator
				| enumerator_list COMMA enumerator;

// Whitespace-separated list of, in any order, one type specifier like void, arithmetic
// or atomic types; zero or more type qualifiers: const, volatile, restrict, _Atomic.
// eg: char int , char , const char , const , long ing , short int , bool , char const
// Retangle , enum{ML, MN}
specifier_qualifier_list	::= type_specifier specifier_qualifier_list
							| type_specifier
							| type_qualifier specifier_qualifier_list
							| type_qualifier;

// Ways of declaring a type, without naming its parts, parameters and such.
// eg: *[] , *[12] , *[i = 0] , *(int x, int y) , *(int, char) , * , [] , 
// [21], () , (int, char)
abstract_declarator	::= pointer direct_abstract_declarator
					| pointer
					| direct_abstract_declarator;

// Variable declarations, bit field declarations, and static assert declarations.
// eg: long int; char ; , _Static_assert(x, "oi");
struct_declaration	::= specifier_qualifier_list SEMICOLON
					| specifier_qualifier_list struct_declarator_list SEMICOLON
					| static_assert_declaration;

// Enumerator includes the values of explicitly named constants (enumeration 
// constants). These new dentifiers must be flagged as ENUMERATION_CONSTANT.
// If enumerator is followed by = constant-expression, its value is the 
// value of that constant expression. If enumerator is not followed by = 
// constant-expression, its value is the value one greater than the value
// of the previous enumerator in the same enumeration. The value of the 
// first enumerator (if it does not use = constant-expression) is zero.
// eg: ML = x, ML
enumerator	::= enumeration_constant ASSIGN constant_expression
			| enumeration_constant;

// Provide type information, without being related to any identifier.
// eg: (*) , ([*]) , ([const]) , [] , [*] , [static const i = 0] , 
// [static i = 0] , [const static i = 0] , [const] , [12] , [i = 0] , [][] , 
// [][*] , [][static const i = 0], [][static i = 0], [][const i = 0] , 
// [][const static i = 0], [][const], [][i = 0] , (), (int x, int y) ,
// (int, char) , []() , [](int x, int y)
direct_abstract_declarator	::= LPAREN abstract_declarator RPAREN
							| LBRACKET RBRACKET
							| LBRACKET MUL RBRACKET
							| LBRACKET STATIC type_qualifier_list assignment_expression RBRACKET
							| LBRACKET STATIC assignment_expression RBRACKET
							| LBRACKET type_qualifier_list STATIC assignment_expression RBRACKET
							| LBRACKET type_qualifier_list assignment_expression RBRACKET
							| LBRACKET type_qualifier_list RBRACKET
							| LBRACKET assignment_expression RBRACKET
							| direct_abstract_declarator LBRACKET RBRACKET
							| direct_abstract_declarator LBRACKET MUL RBRACKET
							| direct_abstract_declarator LBRACKET STATIC type_qualifier_list assignment_expression RBRACKET
							| direct_abstract_declarator LBRACKET STATIC assignment_expression RBRACKET
							| direct_abstract_declarator LBRACKET type_qualifier_list assignment_expression RBRACKET
							| direct_abstract_declarator LBRACKET type_qualifier_list STATIC assignment_expression RBRACKET
							| direct_abstract_declarator LBRACKET type_qualifier_list RBRACKET
							| direct_abstract_declarator LBRACKET assignment_expression RBRACKET
							| LPAREN RPAREN
							| LPAREN parameter_type_list RPAREN
							| direct_abstract_declarator LPAREN RPAREN
							| direct_abstract_declarator LPAREN parameter_type_list RPAREN;

// The iteration statements repeatedly execute a statement.
// eg: while(x > 2) i++; , do i++; while(x > 2); , for(;;) i++; ,
// for(;; i++) a = b + 2; , for(int i = 0; x > 2) i++; , for(int i = 0; x > 2; i++) x += a;
iteration_statement	::= WHILE LPAREN expression RPAREN statement
					| DO statement WHILE LPAREN expression RPAREN SEMICOLON
					| FOR LPAREN expression_statement expression_statement RPAREN statement
					| FOR LPAREN expression_statement expression_statement expression RPAREN statement
					| FOR LPAREN declaration expression_statement RPAREN statement
					| FOR LPAREN declaration expression_statement expression RPAREN statement;

// Comma-separated list of struct declarators.
// eg: b1 : 2, b2 : 4, : 2, b3 : 4
struct_declarator_list	::= struct_declarator
						| struct_declarator_list COMMA struct_declarator;

// Int values named by an enum structure.
// eg: ML , MAX_INT , MIN , STEP
enumeration_constant	::= IDENTIFIER;

// Declares a member with explicit width, in bits. Adjacent bit field members 
// may be packed to share and straddle the individual bytes.
// eg: : 2 , a : 8 , b : 16 , b
struct_declarator	::= COLON constant_expression
					| declarator COLON constant_expression
					| declarator;


// Unknown and unnecessary rules for semantics.
// I've never seen this in my old days of C programming. They're related to
// underscore strange operators: _Static_assert, _Alignas, _Atomic and _Generic.

// The constant expression is evaluated at compile time and compared to zero. If 
// it compares equal to zero, a compile-time error occurs and the compiler must 
// display message as part of the error message (except that characters not 
// in basic source character set aren't required to be displayed).
// eg: _Static_assert(2 + 2 == 4, "Whoa dude!"); , 
// _Static_assert(sizeof(int) < sizeof(char), "this program requires that int is less than char");
static_assert_declaration	::= STATIC_ASSERT LPAREN constant_expression COMMA STRING_LITERAL RPAREN SEMICOLON;

// Appears in the declaration syntax as one of the type specifiers to modify 
// the alignment requirement of the object being declared.
// eg: _Alignas(int) , _Alignas(x)
alignment_specifier	::= ALIGNAS LPAREN type_name RPAREN
					| ALIGNAS LPAREN constant_expression RPAREN;

// Objects of atomic types are the only objects that are free from data races, 
// that is, they may be modified by two threads concurrently or modified by one 
// and read by another.
// eg: _Atomic(int)
atomic_type_specifier	::= ATOMIC LPAREN type_name RPAREN;

// Provides a way to choose one of several expressions at compile time, based on 
// a type of a controlling expression.
// eg: _Generic(x, int: x*2, float: x*2.0) , _Generic(y, default: 10, int: 1, float: 2)
generic_selection	::= GENERIC LPAREN assignment_expression COMMA generic_assoc_list RPAREN;

// Comma-separated list of associations.
// eg: int: x - 2 , int: x + 2, default: x
generic_assoc_list	::= generic_association
					| generic_assoc_list COMMA generic_association;

// No two type-names in the association-list may specify compatible types. 
// There may be only one association that uses the keyword default. If default 
// is not used and none of the type-names are compatible with the type of the 
// controlling expression, the program will not compile.
// eg: int: x - 2 , default: x + 2
generic_association	::= type_name COLON assignment_expression
					| DEFAULT COLON assignment_expression;
