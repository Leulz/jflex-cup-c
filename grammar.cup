import java_cup.runtime.*;
import model.*;

action code {:
  private Semantic semanticAnalyser = new Semantic();
:};

parser code {:
  public parser(java.io.Reader input) {
  	super(new Lexer(input));
  }

  /* Change the method syntax_error so when it reports a syntax
     error it will foward the problematic symbol to report_error.*/
  public void syntax_error(java_cup.runtime.Symbol cur_token) {
  	report_error("Syntax error", cur_token);
  }

  public void unrecovered_syntax_error(java_cup.runtime.Symbol cur_token) {
	report_fatal_error("Syntax error, couldn't repair and continue parse", cur_token);
  }


  /* Change the method report_error so it will display the line and
     column of where the error occurred in the input as well as the
     reason for the error which is passed into the method in the
     String 'message'. It will differ between type of error. */
  public void report_error(String message, Object info) {
  	/* Create a StringBuilder called 'm' with the string 'Error' in it. */
  	StringBuilder m = new StringBuilder("Error");

  	/* Check if the information passed to the method is the same
  	   type as the type java_cup.runtime.Symbol. */
  	if (info instanceof java_cup.runtime.Symbol) {
  		/* Declare a java_cup.runtime.Symbol object 's' with the
  		   information in the object info that is being typecasted
  		   as a java_cup.runtime.Symbol object. */
  		java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

  		/* Check if the line number in the input is greater or
  		   equal to zero. */
  		if (s.left >= 0) {
  			/* Add to the end of the StringBuilder error message
  			   the line number of the error in the input. */
  			m.append(" in line " + (s.left + 1));
  			/* Check if the column number in the input is greater
  			   or equal to zero. */
  			if (s.right >= 0)
  				/* Add to the end of the StringBuilder error message
  				   the column number of the error in the input. */
  				m.append(", column " + (s.right + 1));
  		}
  	}
	
  	/* Add to the end of the StringBuilder error message created in
  	   this method the message that was passed into this method. */
  	m.append(" : " + message);
  	/* Print the contents of the StringBuilder 'm', which contains
  	   an error message, out on a line. */
  	System.err.println(m);
  }

  /* Change the method report_fatal_error so when it reports a fatal
     error it will display the line and column number of where the
     fatal error occurred in the input as well as the reason for the
     fatal error which is passed into the method in the object
     'message' and then exit.*/
  public void report_fatal_error(String message, Object info) {
  	report_error(message, info);
  	System.exit(1);
  }
:};

// Terminals (tokens returned by the scanner)
terminal	IDENTIFIER;
terminal	ENUMERATION_CONSTANT;
terminal	TYPEDEF_NAME;

terminal	AUTO;
terminal	BREAK;
terminal	CASE;
terminal	CHAR;
terminal	CONST;
terminal	CONTINUE;
terminal	DEFAULT;
terminal	DO;
terminal	DOUBLE;
terminal	ELSE;
terminal	ENUM;
terminal	EXTERN;

terminal	FLOAT;
terminal	FOR;
terminal	GOTO;
terminal	IF;
terminal	INLINE;
terminal	INT;
terminal	LONG;
terminal	REGISTER;
terminal	RESTRICT;
terminal	RETURN;
terminal	SHORT;

terminal	SIGNED;
terminal	SIZEOF;
terminal	STATIC;
terminal	STRUCT;
terminal	SWITCH;
terminal	TYPEDEF;
terminal	UNION;
terminal	UNSIGNED;
terminal	VOID;
terminal	VOLATILE;
terminal	WHILE;

terminal	ALIGNAS;
terminal	ALIGNOF;
terminal	ATOMIC;
terminal	BOOL;
terminal	COMPLEX;
terminal	GENERIC;
terminal	IMAGINARY;
terminal	NORETURN;
terminal	STATIC_ASSERT;
terminal	THREAD_LOCAL;

terminal	FUNC_NAME;
terminal	I_CONSTANT;
terminal	F_CONSTANT;
terminal	STRING_LITERAL;

terminal	ELLIPSIS;		// ...
terminal	RIGHT_ASSIGN;	// >>=
terminal	LEFT_ASSIGN;	// <<=
terminal	ADD_ASSIGN;		// +=
terminal	SUB_ASSIGN;		// -=
terminal	MUL_ASSIGN;		// *=
terminal	DIV_ASSIGN;		// /=
terminal	MOD_ASSIGN;		// %=
terminal	AND_ASSIGN;		// &=
terminal	XOR_ASSIGN;		// ^=
terminal	OR_ASSIGN;		// |=
terminal	RIGHT_OP;		// >>
terminal	LEFT_OP;		// <<
terminal	INC_OP;			// ++
terminal	DEC_OP;			// --
terminal	PTR_OP;			// ->
terminal	AND_OP;			// &&
terminal	OR_OP;			// ||
terminal	LE_OP;			// <=
terminal	GE_OP;			// >=
terminal	EQ_OP;			// ==
terminal	NE_OP;			// !=

terminal	SEMICOLON;	// ;
terminal	LCURLY;		// {
terminal	RCURLY;		// }
terminal	COMMA;		// ,
terminal	COLON;		// :
terminal	ASSIGN;		// =
terminal	LPAREN;		// (
terminal	RPAREN;		// )
terminal	LBRACKET;	// [
terminal	RBRACKET;	// ]
terminal	DOT;		// .
terminal	AND;		// &
terminal	NE;			// !
terminal	COMPLEMENT;	// ~
terminal	SUB;		// -
terminal	ADD;		// +
terminal	MUL;		// *
terminal	DIV;		// /
terminal	MOD;		// %
terminal	LE;			// <
terminal	GE;			// >
terminal	XOR;		// ^
terminal	OR;			// |
terminal	QUESTION;	// ?

// Nonterminals
non terminal translation_unit, external_declaration, function_definition, declaration_list, primary_expression;
non terminal constant, enumeration_constant, string, generic_selection, generic_assoc_list, generic_association;
non terminal postfix_expression, argument_expression_list, unary_expression, unary_operator, cast_expression;
non terminal multiplicative_expression, additive_expression, shift_expression, relational_expression;
non terminal equality_expression, and_expression, exclusive_or_expression, inclusive_or_expression;
non terminal logical_and_expression, logical_or_expression, conditional_expression, assignment_expression;
non terminal assignment_operator, expression, constant_expression, declaration, declaration_specifiers;
non terminal init_declarator_list, init_declarator, storage_class_specifier, type_specifier, struct_or_union_specifier;
non terminal struct_or_union, struct_declaration_list, struct_declaration, specifier_qualifier_list, struct_declarator_list;
non terminal struct_declarator, enum_specifier, enumerator_list, enumerator, atomic_type_specifier, type_qualifier;
non terminal function_specifier, alignment_specifier, declarator, direct_declarator, pointer, type_qualifier_list;
non terminal parameter_type_list, parameter_list, parameter_declaration, identifier_list, type_name, abstract_declarator;
non terminal direct_abstract_declarator, initializer, initializer_list, designation, designator_list, designator;
non terminal static_assert_declaration, statement, labeled_statement, compound_statement, block_item_list;
non terminal block_item, expression_statement, selection_statement, iteration_statement, jump_statement;

precedence nonassoc ELSE;
precedence nonassoc ATOMIC;

start with translation_unit;

translation_unit	::= external_declaration
					| translation_unit external_declaration;

external_declaration	::= function_definition
						| declaration;

function_definition	::= declaration_specifiers declarator declaration_list compound_statement
					| declaration_specifiers declarator compound_statement;

// A declaration is a C language construct that introduces one or more identifiers 
// into the program and specifies their meaning and properties. The enum, struct, 
// and union declarations may omit declarators. Can be a static-assert declaration.
// eg: enum COLOR {RED, GREEN, BLUE}; , const int *f(void); , int a, *b=NULL; ,
// _Static_assert(2 + 2 == 4, "Whoa dude!");
declaration	::= declaration_specifiers SEMICOLON
			| declaration_specifiers:t init_declarator_list:v SEMICOLON {: semanticAnalyser.commitDeclaredVariables((Type) t); :}
			| static_assert_declaration;

// Whitespace-separated list of, in any order, one type specifier like void, arithmetic
// or atomic types; zero or one storage-class specifiers: typedef, auto, register, static, 
// extern, thread_local; zero or more type qualifiers: const, volatile, restrict, _Atomic;
// (only when declaring functions), zero or more function specifier: inline, noreturn;
// zero or more alignment specifiers: alignas.
// eg: typedef static , static , int static , int , const static , const , 
// inline const , inline , _Alignas() static , _Alignas()
declaration_specifiers	::= storage_class_specifier declaration_specifiers:t {: RESULT = t; :}
						| storage_class_specifier
						| type_specifier declaration_specifiers
						| type_specifier:t {: RESULT = t; :}
						| type_qualifier declaration_specifiers
						| type_qualifier
						| function_specifier declaration_specifiers
						| function_specifier
						| alignment_specifier declaration_specifiers
						| alignment_specifier;

// Provides type information and/or the identifier to declare, can be a
// pointer declaration: the declaration S * cvr D; declares D as a 
// cvr-qualified pointer to the type determined by S.
// eg: a , *b , *f(void) , *f(int i, int a)
declarator	::= pointer direct_declarator
			| direct_declarator:v {: RESULT=v; :};

// Set of declarations in sequence.
// eg: int i = 0; int j = 1 , char c;
declaration_list	::= declaration
					| declaration_list declaration;

// A compound statement, or block, is a brace-enclosed sequence of statements and declarations.
// eg: {} , { int i = 0; } , {int i = 0; printf(i++); printf(i++);}
compound_statement	::= LCURLY RCURLY
					| LCURLY  block_item_list RCURLY;


// Comma-separated list of declarators (each declarator provides additional 
// type information and/or the identifier to declare).
// eg: c = 3, i = 2 , *x = &i, *y = &j , a = 1
init_declarator_list	::= init_declarator:v {: RESULT=v; :}
						| init_declarator_list COMMA init_declarator;

// Storage-class specifiers appear in declarations. At most one specifier may be 
// used, except that _Thread_local may be combined with static or extern to adjust
// linkage. The storage-class specifiers determine two independent properties of 
// the names they declare: storage duration and linkage.
// eg: typedef , extern , static , _Thread_local , auto , register
storage_class_specifier ::= TYPEDEF
						| EXTERN
						| STATIC
						| THREAD_LOCAL
						| AUTO
						| REGISTER;

// All keywords or expressions that represents the type of a value: can be void, an
// an arithmetic type, an atomic type, a name earlier introduced by a typedef declaration,
// struct, union, or enum specifier.
// eg: void , char , short , int , long , float , double , signed , unsigned ,
// bool , _Complex , _Imaginary , _Atomic(int) , enum{ML, MN} , Retangle
type_specifier	::= VOID
				| CHAR
				| SHORT
				| INT:i {: RESULT = new Type("int"); :}
				| LONG
				| FLOAT
				| DOUBLE
				| SIGNED
				| UNSIGNED
				| BOOL
				| COMPLEX
				| IMAGINARY
				| atomic_type_specifier
				| struct_or_union_specifier
				| enum_specifier
				| TYPEDEF_NAME;

// Each individual type in the C type system has several qualified versions of 
// that type, corresponding to one, two, or all four of the const, volatile, _Atomic, 
// and, for pointers to object types, restrict qualifiers.
// eg: const , restrict , volatile , _Atomic
type_qualifier	::= CONST
				| RESTRICT
				| VOLATILE
				| ATOMIC;

// Function specifiers appear in declarations. They can be used together, serving 
// as a hint for the compiler to perform optimizations, such as function inlining.
// eg: inline , _Noreturn
function_specifier	::= INLINE
					| NORETURN;

// Pointer is a type of an object that refers to a function or an object of 
// another type, possibly adding qualifiers. Pointer may also refer to nothing,
// which is indicated by the special null pointer value.
// eg: *p, **p , * const pc , * const * pc , ** , * 
pointer	::= MUL type_qualifier_list pointer
		| MUL type_qualifier_list
		| MUL pointer
		| MUL;

// Provide type information and/or identifier to declare. Can be the identifier
// that this declarator introduces; any declarator may be enclosed in parentheses;
// can be an array declarator: the declaration S D[N] declares D as an array of N 
// objects of the type determined by S; can be function declarator: the 
// declaration S D(params) declared D as a function taking the parameters params 
// and returning S.
// eg: x , (x) , (*obj), m[] , m[*] , m[20] , x[i = 0], x(int, int) , x(), 
// x(a, b, c)
direct_declarator	::= IDENTIFIER:id {: System.out.println("Saw an identifier in a declaration.");
                                      Variable v = new Variable((String) id, new Type("null"));
                                      semanticAnalyser.addScopedVar(v);
                                      RESULT = v; :}
					| LPAREN declarator RPAREN
					| direct_declarator LBRACKET RBRACKET
					| direct_declarator LBRACKET MUL RBRACKET
					| direct_declarator LBRACKET STATIC type_qualifier_list assignment_expression RBRACKET
					| direct_declarator LBRACKET STATIC assignment_expression RBRACKET
					| direct_declarator LBRACKET type_qualifier_list MUL RBRACKET
					| direct_declarator LBRACKET type_qualifier_list STATIC assignment_expression RBRACKET
					| direct_declarator LBRACKET type_qualifier_list assignment_expression RBRACKET
					| direct_declarator LBRACKET type_qualifier_list RBRACKET
					| direct_declarator LBRACKET assignment_expression RBRACKET
					| direct_declarator LPAREN parameter_type_list RPAREN
					| direct_declarator LPAREN RPAREN
					| direct_declarator LPAREN identifier_list RPAREN;

// Set of declarations and statements at sequence.
// eg: int i = 0; , int i = 0; printf(i++); printf(i++);
block_item_list	::= block_item
				| block_item_list block_item;

// Declarators may be accompanied by initializers. The enum, struct, and union 
// declarations may omit declarators, in which case they only introduce 
// the enumeration constants and/or tags.
// eg: *x = &a, c = 3 , c , *f(void) = &calc
init_declarator	::= declarator ASSIGN initializer
				| declarator:v {: RESULT=v; :};

// Several varieties of expressions are known as constant expressions. They need
// to have values available at compile time. Thus, it contains some constraints.
// eg: 12, 14, 3.14
constant_expression	::= conditional_expression;

// Defines an abstract data type, with struct or union.
// eg: struct {} , struct Retangle {} , struct Retangle
struct_or_union_specifier	::= struct_or_union LCURLY struct_declaration_list RCURLY
							| struct_or_union IDENTIFIER LCURLY struct_declaration_list RCURLY
							| struct_or_union IDENTIFIER;

// An enumerated type is a distinct type whose value is a value of its 
// underlying type, which includes the values of explicitly named constants 
// (enumeration constants).
// eg: enum{RED, GREEN, BLUE} , enum{RED = -1, GREEN, BLUE,} , 
// enum colors{RED, GREEN, BLUE}
enum_specifier	::= ENUM LCURLY enumerator_list RCURLY
				| ENUM LCURLY enumerator_list COMMA RCURLY
				| ENUM IDENTIFIER LCURLY enumerator_list RCURLY
				| ENUM IDENTIFIER LCURLY enumerator_list COMMA RCURLY
				| ENUM IDENTIFIER;

// A set of names that defines the type of a value.
// eg: int[] , int (*int, *int) , char[30] , *void() , int, long int
type_name	::= specifier_qualifier_list abstract_declarator
			| specifier_qualifier_list;

// List of keywords changing the aspect of a value.
// eg: const , volatile const
type_qualifier_list	::= type_qualifier
					| type_qualifier_list type_qualifier;

// Here we defined the 14º precedence on operators in C, the assignment operators, 
// which can be used to assign values (expressions) to variables. The unary operators
// are the only ones allowed to operate on the variables receiving values.
// eg: x , a + b , i++ , x++ = a + b , a += m , i *= 2
assignment_expression	::= conditional_expression
						| unary_expression assignment_operator assignment_expression;

// eg: int x, int y, ... , int x
parameter_type_list	::= parameter_list COMMA ELLIPSIS
					| parameter_list;

// eg: x , x, a, b
identifier_list	::= IDENTIFIER
				| identifier_list COMMA IDENTIFIER;

// Block item, it's a declaration or a statement.
// eg: int i = 0; , f(1, 3); , printf("Oi");
block_item	::= declaration
			| statement;

// A declaration of an object may provide its initial value through the 
// process known as initialization. For each declarator, the initializer, 
// if not omitted, may be a expression, or a initializer-list.
// eg: {[0].a = {1}, [1].a[0] = 2} , {1, 2, 3,} , x + a , 12.2 , "oi"
initializer	::= LCURLY initializer_list RCURLY
			| LCURLY initializer_list COMMA RCURLY
			| assignment_expression;

// Here we defined the 13º precedence on operators in C, the ternary conditional "?:",
// which allows to create a mini if-then-else calculation. Note the restriction on the values to
// be evaluated as bool or not, and the else value.
// eg: x , a + b , i++ , x > 2 ? 12 : x + 12 , condition ? i += 2 : condition2 ? j += 2 : 0
conditional_expression	::= logical_or_expression
						| logical_or_expression QUESTION expression COLON conditional_expression;

// Keywords that enable creation of abstract data types.
// eg: struct , union
struct_or_union ::= STRUCT
				| UNION;

// Any number of variable declarations, bit field declarations, and static assert 
// declarations. Members of incomplete type and members of function type are not 
// allowed.
// eg: int i, j; , int x; char *c;
struct_declaration_list	::= struct_declaration
						| struct_declaration_list struct_declaration;

// Enumerator-list is a comma-separated list (with trailing comma permitted) 
// (since C99) of enumerators, each of which has the form: enumerator = 
// constant-expression, where enumerator are identifiers introduced by this 
// declaration.
// eg: RED, GREEN, BLUE , RED = -1, GREEN, BLUE
enumerator_list	::= enumerator
				| enumerator_list COMMA enumerator;

// Whitespace-separated list of, in any order, one type specifier like void, arithmetic
// or atomic types; zero or more type qualifiers: const, volatile, restrict, _Atomic.
// eg: char int , char , const char , const , long ing , short int , bool , char const
// Retangle , enum{ML, MN}
specifier_qualifier_list	::= type_specifier specifier_qualifier_list
							| type_specifier
							| type_qualifier specifier_qualifier_list
							| type_qualifier;

// Ways of declaring a type, without naming its parts, parameters and such.
// eg: *[] , *[12] , *[i = 0] , *(int x, int y) , *(int, char) , * , [] , 
// [21], () , (int, char)
abstract_declarator	::= pointer direct_abstract_declarator
					| pointer
					| direct_abstract_declarator;

// Here we defined the rest of the operators at 2º precedence in C, unary
// operators like "i++" or "!(x >= 2)", they only are applied when put 
// right before the expression, "prefixed" to the expression to change. 
// It's used to execute various operations in C, but it affects only one 
// expression at a time.
// eg: x , s[i] , ++x , --x , -b , *b , ~2 , !(a || b) , *(int) x , 
// sizeof x , sizeof(int) , _Alignof(int)
unary_expression	::= postfix_expression
					| INC_OP unary_expression
					| DEC_OP unary_expression
					| unary_operator cast_expression
					| SIZEOF unary_expression
					| SIZEOF LPAREN type_name RPAREN
					| ALIGNOF LPAREN type_name RPAREN;

// All assignment operators on C. Besides the assignment function
// some executes different operations related to the value that
// existed before the assignment.
// eg: = , *= , /= , %= , += , -= , <<= , >>= , &= , ^= , |=
assignment_operator	::= ASSIGN
					| MUL_ASSIGN
					| DIV_ASSIGN
					| MOD_ASSIGN
					| ADD_ASSIGN
					| SUB_ASSIGN
					| LEFT_ASSIGN
					| RIGHT_ASSIGN
					| AND_ASSIGN
					| XOR_ASSIGN
					| OR_ASSIGN;

// eg: int x , int x, int y , int, char
parameter_list	::= parameter_declaration
				| parameter_list COMMA parameter_declaration;

statement	::= labeled_statement
			| compound_statement
			| expression_statement
			| selection_statement
			| iteration_statement
			| jump_statement;

// A initializer-list is a non-empty comma-separated list of initializers (with 
// an optional trailing comma), where each initializer has one of three 
// possible forms: expression, {initializer_list} or designator_list = expression.
// eg: [0].a = {1} , x , 12 , [0].a = {1}, [1].a[0] = 2 , 1, 2, 3
initializer_list	::= designation initializer
					| initializer
					| initializer_list COMMA designation initializer
					| initializer_list COMMA initializer;

// Here we defined the 12º precedence on operators in C, the logical or "||".
// It's used to evaluate bool values on the conditions in C.
// eg: x , a + b , x || a , a || b || c , a || b && c
logical_or_expression	::= logical_and_expression
						| logical_or_expression OR_OP logical_and_expression;

// Its anything that can be evaluated to a value of any type available or defined.
// Here, we define the lowest precedence (15º) of the operators on C, the "," that
// tie expressions to be passed as functions parameters or declarations.
// eg: x , a = 2 , a + b , a + (-b) , x, a = 2
expression	::= assignment_expression
			| expression COMMA assignment_expression;

// Variable declarations, bit field declarations, and static assert declarations.
// eg: long int; char ; , _Static_assert(x, "oi");
struct_declaration	::= specifier_qualifier_list SEMICOLON
					| specifier_qualifier_list struct_declarator_list SEMICOLON
					| static_assert_declaration;

// Enumerator includes the values of explicitly named constants (enumeration 
// constants). These new dentifiers must be flagged as ENUMERATION_CONSTANT.
// If enumerator is followed by = constant-expression, its value is the 
// value of that constant expression. If enumerator is not followed by = 
// constant-expression, its value is the value one greater than the value
// of the previous enumerator in the same enumeration. The value of the 
// first enumerator (if it does not use = constant-expression) is zero.
// eg: ML = x, ML
enumerator	::= enumeration_constant ASSIGN constant_expression
			| enumeration_constant;

// Provide type information, without being related to any identifier.
// eg: (*) , ([*]) , ([const]) , [] , [*] , [static const i = 0] , 
// [static i = 0] , [const static i = 0] , [const] , [12] , [i = 0] , [][] , 
// [][*] , [][static const i = 0], [][static i = 0], [][const i = 0] , 
// [][const static i = 0], [][const], [][i = 0] , (), (int x, int y) ,
// (int, char) , []() , [](int x, int y)
direct_abstract_declarator	::= LPAREN abstract_declarator RPAREN
							| LBRACKET RBRACKET
							| LBRACKET MUL RBRACKET
							| LBRACKET STATIC type_qualifier_list assignment_expression RBRACKET
							| LBRACKET STATIC assignment_expression RBRACKET
							| LBRACKET type_qualifier_list STATIC assignment_expression RBRACKET
							| LBRACKET type_qualifier_list assignment_expression RBRACKET
							| LBRACKET type_qualifier_list RBRACKET
							| LBRACKET assignment_expression RBRACKET
							| direct_abstract_declarator LBRACKET RBRACKET
							| direct_abstract_declarator LBRACKET MUL RBRACKET
							| direct_abstract_declarator LBRACKET STATIC type_qualifier_list assignment_expression RBRACKET
							| direct_abstract_declarator LBRACKET STATIC assignment_expression RBRACKET
							| direct_abstract_declarator LBRACKET type_qualifier_list assignment_expression RBRACKET
							| direct_abstract_declarator LBRACKET type_qualifier_list STATIC assignment_expression RBRACKET
							| direct_abstract_declarator LBRACKET type_qualifier_list RBRACKET
							| direct_abstract_declarator LBRACKET assignment_expression RBRACKET
							| LPAREN RPAREN
							| LPAREN parameter_type_list RPAREN
							| direct_abstract_declarator LPAREN RPAREN
							| direct_abstract_declarator LPAREN parameter_type_list RPAREN;

// Here we defined the operators at 1º precedence in C, postfix operators 
// like "a[i]" or "calc()", they only are applied when put right after the 
// expression, "postfixed" to the expression to change.
// It's used to execute plenty things in C, affecting only one expression
// at a time. They are related to value addressing, and function execution, 
// hence the high priority.
// eg: x , x(20) , f() , f(a = 2, b = 3) , x.a , x->a , x++ , x-- , 
// (Retangle){a = 2} , {Retangle}{a = 2,}
postfix_expression	::= primary_expression
					| postfix_expression LBRACKET expression RBRACKET
					| postfix_expression LPAREN RPAREN
					| postfix_expression LPAREN argument_expression_list RPAREN
					| postfix_expression DOT IDENTIFIER
					| postfix_expression PTR_OP IDENTIFIER
					| postfix_expression INC_OP
					| postfix_expression DEC_OP
					| LPAREN type_name RPAREN LCURLY initializer_list RCURLY
					| LPAREN type_name RPAREN LCURLY initializer_list COMMA RCURLY;

// All of prefixed unary operators on C. Perform various operations
// at number, logical or bitwise scope.
// eg: & , * , + , - , ~ , !
unary_operator	::= AND
				| MUL
				| ADD
				| SUB
				| COMPLEMENT
				| NE;

// Here we defined one of the operators at 2º precedence in C, the cast
// operation like "(int) x" or "(float) 2 / 12". It's used to transform 
// values to different types in C.
// eg: x , a[i++] , (int) x , (float) 2 , (float) ++i
cast_expression	::= unary_expression
				| LPAREN type_name RPAREN cast_expression;

// eg: int x , int* , int[][] , int
parameter_declaration	::= declaration_specifiers declarator
						| declaration_specifiers abstract_declarator
						| declaration_specifiers;

labeled_statement	::= IDENTIFIER COLON statement
					| CASE constant_expression COLON statement
					| DEFAULT COLON statement;

// eg: ; , x = 1;
expression_statement	::= SEMICOLON
						| expression SEMICOLON;

// eg: if(x > 2) a = x; else a = y; , if(x > 2) a = x; , switch(x) a = x;
selection_statement	::= IF LPAREN expression RPAREN statement ELSE statement
					| IF LPAREN expression RPAREN statement
					| SWITCH LPAREN expression RPAREN statement;

// eg: while(x > 2) i++; , do i++; while(x > 2); , for(;;) i++; ,
// for(;; i++) a = b + 2; , for(int i = 0; x > 2) i++; , for(int i = 0; x > 2; i++) x += a;
iteration_statement	::= WHILE LPAREN expression RPAREN statement
					| DO statement WHILE LPAREN expression RPAREN SEMICOLON
					| FOR LPAREN expression_statement expression_statement RPAREN statement
					| FOR LPAREN expression_statement expression_statement expression RPAREN statement
					| FOR LPAREN declaration expression_statement RPAREN statement
					| FOR LPAREN declaration expression_statement expression RPAREN statement;

// eg: goto start; , continue; , break; , return; , return x + 1;
jump_statement	::= GOTO IDENTIFIER SEMICOLON
				| CONTINUE SEMICOLON
				| BREAK SEMICOLON
				| RETURN SEMICOLON
				| RETURN expression SEMICOLON;

// Assignment of a designator_list, that usualy it's inside a declaration.
// eg: [i][j] = , [x].a = , .left.left =
designation	::= designator_list ASSIGN;

// Here we defined the 11º precedence on operators in C, the logical and "&&".
// It's used to evaluate bool values on the conditions in C.
// eg: x , a + b , a[i] , x && a , a && b && c , a && b && !c
logical_and_expression	::= inclusive_or_expression
						| logical_and_expression AND_OP inclusive_or_expression;

// Comma-separated list of struct declarators.
// eg: b1 : 2, b2 : 4, : 2, b3 : 4
struct_declarator_list	::= struct_declarator
						| struct_declarator_list COMMA struct_declarator;

// Int values named by an enum structure.
// eg: ML , MAX_INT , MIN , STEP
enumeration_constant	::= IDENTIFIER;

// The foremost basic element of an expression, comprehends identifiers,
// numbers constants, strings, expression on parenthesis and generics selections.
// eg: x , a , b , 11 , 12.2 , 0xA2 , "oi" , "tchau" , "Hi, Leo!" , 
// (x >= 2) , (a == (i = j + i + 1)) , _Generic(x = 1, int: x = 2)
primary_expression	::= IDENTIFIER
					| constant
					| string
					| LPAREN expression RPAREN
					| generic_selection;

// eg: x = a + 2 , x = 2, a = 0
argument_expression_list	::= assignment_expression
							| argument_expression_list COMMA assignment_expression;

// Designator-list is a list of either array designators of the form 
// [constant-expression] or struct/union member designators of the form
// .identifier ;
// eg: [i] , [i][j] , .left.left
designator_list	::= designator
				| designator_list designator;

// Here we defined the 10º precedence on operators in C, the bitwise or "|".
// It's used to evaluate bitwise values in C.
// eg: x , a + b , a[i] , x | y , a | b | c , a ^ b & c , a << 2 | b
inclusive_or_expression	::= exclusive_or_expression
						| inclusive_or_expression OR exclusive_or_expression;

// Declares a member with explicit width, in bits. Adjacent bit field members 
// may be packed to share and straddle the individual bytes.
// eg: : 2 , a : 8 , b : 16 , b
struct_declarator	::= COLON constant_expression
					| declarator COLON constant_expression
					| declarator;

// Constant values of certain types may be embedded in the source code of a C 
// program using specialized expressions known as literals (for lvalue 
// expressions) and constants (for non-lvalue expressions).
// eg: 1001 , 20.5 , 0xA3 , 0732 , MAX
constant	::= I_CONSTANT
			| F_CONSTANT
			| ENUMERATION_CONSTANT;

// Constructs an unnamed object of specified character array type in-place, 
// used when a character string needs to be embedded in source code.
// eg: "oi" , "Hi, Dênnis!" , __func__
string	::= STRING_LITERAL
		| FUNC_NAME;

// It specifies an adress related to the Identifier, like in
// ball[12] or ball.radius.
// eg: [i] , [12] , .radius
designator	::= LBRACKET constant_expression RBRACKET
			| DOT IDENTIFIER;

// Here we defined the 9º precedence on operators in C, the bitwise 
// exclusive or "^". It's used to evaluate bitwise values in C.
// eg: x , a + b , a[i] , x ^ y , x ^ y && b , a ^ b ^ c
exclusive_or_expression	::= and_expression
						| exclusive_or_expression XOR and_expression;

// Here we defined the 8º precedence on operators in C, the bitwise and "&". 
// It's used to evaluate bitwise values in C.
// eg: x , a + b , x[i] , x & y , x & y & c , a << 2 & c
and_expression	::= equality_expression
				| and_expression AND equality_expression;

// Here we defined the 7º precedence on operators in C, the equality operators.
// "==" and "!=". It's used to evaluate boolean values in C.
// eg: x , a + b , x == 0 , x != 12 , a >= 2 , i - 2 == 3
equality_expression	::= relational_expression
					| equality_expression EQ_OP relational_expression
					| equality_expression NE_OP relational_expression;

// Here we defined the 6º precedence on operators in C, the relational operators.
// It's used to evaluate boolean values in C.
// eg: x , a + b , a[i] , x < 2 , x > a , x <= 12 , x >= b
relational_expression	::= shift_expression
						| relational_expression LE shift_expression
						| relational_expression GE shift_expression
						| relational_expression LE_OP shift_expression
						| relational_expression GE_OP shift_expression;

// Here we defined the 5º precedence on operators in C, the shift operators.
// It's used to evaluate bitwise values in C, or calculate exponential with 2
// as a base.
// eg: x , a + b , a[i] , x << 2 , x >> a
shift_expression	::= additive_expression
					| shift_expression LEFT_OP additive_expression
					| shift_expression RIGHT_OP additive_expression;

// Here we defined the 4º precedence on operators in C, the addition operators.
// It's used to evaluate numbers values in C, in addition or subtraction.
// eg: x , a[i] , x + 2 , x - 3 , x*2 + 3
additive_expression	::= multiplicative_expression
					| additive_expression ADD multiplicative_expression
					| additive_expression SUB multiplicative_expression;

// Here we defined the 3º precedence on operators in C, the multiplicative
// operators like "*", "/" and "%". It's used to evaluate numbers values in
// C, in multiplication or remainder calculation.
// eg: x , x * 2 , x / a , x % 5 , 2*x++
multiplicative_expression	::= cast_expression
							| multiplicative_expression MUL cast_expression
							| multiplicative_expression DIV cast_expression
							| multiplicative_expression MOD cast_expression;


// Unknown and unnecessary rules for semantics.
// I've never seen this in my old days of C programming. They're related to
// underscore strange operators: _Static_assert, _Alignas, _Atomic and _Generic.

// The constant expression is evaluated at compile time and compared to zero. If 
// it compares equal to zero, a compile-time error occurs and the compiler must 
// display message as part of the error message (except that characters not 
// in basic source character set aren't required to be displayed).
// eg: _Static_assert(2 + 2 == 4, "Whoa dude!"); , 
// _Static_assert(sizeof(int) < sizeof(char), "this program requires that int is less than char");
static_assert_declaration	::= STATIC_ASSERT LPAREN constant_expression COMMA STRING_LITERAL RPAREN SEMICOLON;

// Appears in the declaration syntax as one of the type specifiers to modify 
// the alignment requirement of the object being declared.
// eg: _Alignas(int) , _Alignas(x)
alignment_specifier	::= ALIGNAS LPAREN type_name RPAREN
					| ALIGNAS LPAREN constant_expression RPAREN;

// Objects of atomic types are the only objects that are free from data races, 
// that is, they may be modified by two threads concurrently or modified by one 
// and read by another.
// eg: _Atomic(int)
atomic_type_specifier	::= ATOMIC LPAREN type_name RPAREN;

// Provides a way to choose one of several expressions at compile time, based on 
// a type of a controlling expression.
// eg: _Generic(x, int: x*2, float: x*2.0) , _Generic(y, default: 10, int: 1, float: 2)
generic_selection	::= GENERIC LPAREN assignment_expression COMMA generic_assoc_list RPAREN;

// Comma-separated list of associations.
// eg: int: x - 2 , int: x + 2, default: x
generic_assoc_list	::= generic_association
					| generic_assoc_list COMMA generic_association;

// No two type-names in the association-list may specify compatible types. 
// There may be only one association that uses the keyword default. If default 
// is not used and none of the type-names are compatible with the type of the 
// controlling expression, the program will not compile.
// eg: int: x - 2 , default: x + 2
generic_association	::= type_name COLON assignment_expression
					| DEFAULT COLON assignment_expression;